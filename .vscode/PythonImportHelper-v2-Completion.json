[
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "winreg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "winreg",
        "description": "winreg",
        "detail": "winreg",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "pythoncom",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pythoncom",
        "description": "pythoncom",
        "detail": "pythoncom",
        "documentation": {}
    },
    {
        "label": "win32api",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32api",
        "description": "win32api",
        "detail": "win32api",
        "documentation": {}
    },
    {
        "label": "win32con",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32con",
        "description": "win32con",
        "detail": "win32con",
        "documentation": {}
    },
    {
        "label": "win32file",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32file",
        "description": "win32file",
        "detail": "win32file",
        "documentation": {}
    },
    {
        "label": "wmi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "wmi",
        "description": "wmi",
        "detail": "wmi",
        "documentation": {}
    },
    {
        "label": "escape",
        "importPath": "cgi",
        "description": "cgi",
        "isExtraImport": true,
        "detail": "cgi",
        "documentation": {}
    },
    {
        "label": "make_server",
        "importPath": "wsgiref.simple_server",
        "description": "wsgiref.simple_server",
        "isExtraImport": true,
        "detail": "wsgiref.simple_server",
        "documentation": {}
    },
    {
        "label": "request_uri",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "application_uri",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "shift_path_info",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "statistics",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "statistics",
        "description": "statistics",
        "detail": "statistics",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "psutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psutil",
        "description": "psutil",
        "detail": "psutil",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "send2trash",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "send2trash",
        "description": "send2trash",
        "detail": "send2trash",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "update_structure_file",
        "importPath": "update_structure",
        "description": "update_structure",
        "isExtraImport": true,
        "detail": "update_structure",
        "documentation": {}
    },
    {
        "label": "aggregator",
        "importPath": "modes.cpu",
        "description": "modes.cpu",
        "isExtraImport": true,
        "detail": "modes.cpu",
        "documentation": {}
    },
    {
        "label": "get_cpu_speed",
        "importPath": "modes.cpu.cpuspeed",
        "description": "modes.cpu.cpuspeed",
        "isExtraImport": true,
        "detail": "modes.cpu.cpuspeed",
        "documentation": {}
    },
    {
        "label": "get_cpu_temp",
        "importPath": "modes.cpu.cputemp",
        "description": "modes.cpu.cputemp",
        "isExtraImport": true,
        "detail": "modes.cpu.cputemp",
        "documentation": {}
    },
    {
        "label": "get_cpu_usage",
        "importPath": "modes.cpu.cpu_usage",
        "description": "modes.cpu.cpu_usage",
        "isExtraImport": true,
        "detail": "modes.cpu.cpu_usage",
        "documentation": {}
    },
    {
        "label": "Tee",
        "kind": 6,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "class Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except OSError:\n                pass\n        tee_f.write(what)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_root_hkey",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU\n        return winreg.HKEY_CURRENT_USER",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "create_shortcut",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def create_shortcut(\n    path, description, filename, arguments=\"\", workdir=\"\", iconpath=\"\", iconindex=0\n):\n    import pythoncom\n    from win32com.shell import shell\n    ilink = pythoncom.CoCreateInstance(\n        shell.CLSID_ShellLink,\n        None,\n        pythoncom.CLSCTX_INPROC_SERVER,\n        shell.IID_IShellLink,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_special_folder_path",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_special_folder_path(path_name):\n    from win32com.shell import shell, shellcon\n    for maybe in \"\"\"\n        CSIDL_COMMON_STARTMENU CSIDL_STARTMENU CSIDL_COMMON_APPDATA\n        CSIDL_LOCAL_APPDATA CSIDL_APPDATA CSIDL_COMMON_DESKTOPDIRECTORY\n        CSIDL_DESKTOPDIRECTORY CSIDL_COMMON_STARTUP CSIDL_STARTUP\n        CSIDL_COMMON_PROGRAMS CSIDL_PROGRAMS CSIDL_PROGRAM_FILES_COMMON\n        CSIDL_PROGRAM_FILES CSIDL_FONTS\"\"\".split():\n        if maybe == path_name:\n            csidl = getattr(shellcon, maybe)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "CopyTo",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def CopyTo(desc, src, dest):\n    import win32api\n    import win32con\n    while 1:\n        try:\n            win32api.CopyFile(src, dest, 0)\n            return\n        except win32api.error as details:\n            if details.winerror == 5:  # access denied - user not admin.\n                raise",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "LoadSystemModule",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def LoadSystemModule(lib_dir, modname):\n    # See if this is a debug build.\n    import importlib.machinery\n    import importlib.util\n    suffix = \"_d\" if \"_d.pyd\" in importlib.machinery.EXTENSION_SUFFIXES else \"\"\n    filename = \"%s%d%d%s.dll\" % (\n        modname,\n        sys.version_info.major,\n        sys.version_info.minor,\n        suffix,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "SetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def SetPyKeyVal(key_name, value_name, value):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.CreateKey(root_key, key_name)\n        try:\n            winreg.SetValueEx(my_key, value_name, 0, winreg.REG_SZ, value)\n            if verbose:\n                print(f\"-> {root_key_name}\\\\{key_name}[{value_name}]={value!r}\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "UnsetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def UnsetPyKeyVal(key_name, value_name, delete_key=False):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.OpenKey(root_key, key_name, 0, winreg.KEY_SET_VALUE)\n        try:\n            winreg.DeleteValue(my_key, value_name)\n            if verbose:\n                print(f\"-> DELETE {root_key_name}\\\\{key_name}[{value_name}]\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterCOMObjects",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterCOMObjects(register=True):\n    import win32com.server.register\n    if register:\n        func = win32com.server.register.RegisterClasses\n    else:\n        func = win32com.server.register.UnregisterClasses\n    flags = {}\n    if not verbose:\n        flags[\"quiet\"] = 1\n    for module, klass_name in com_modules:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterHelpFile",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterHelpFile(register=True, lib_dir=None):\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    if register:\n        # Register the .chm help file.\n        chm_file = os.path.join(lib_dir, \"PyWin32.chm\")\n        if os.path.isfile(chm_file):\n            # This isn't recursive, so if 'Help' doesn't exist, we croak\n            SetPyKeyVal(\"Help\", None, None)\n            SetPyKeyVal(\"Help\\\\Pythonwin Reference\", None, chm_file)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterPythonwin",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterPythonwin(register=True, lib_dir=None):\n    \"\"\"Add (or remove) Pythonwin to context menu for python scripts.\n    ??? Should probably also add Edit command for pys files also.\n    Also need to remove these keys on uninstall, but there's no function\n    to add registry entries to uninstall log ???\n    \"\"\"\n    import os\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    classes_root = get_root_hkey()",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_shortcuts_folder",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_shortcuts_folder():\n    if get_root_hkey() == winreg.HKEY_LOCAL_MACHINE:\n        try:\n            fldr = get_special_folder_path(\"CSIDL_COMMON_PROGRAMS\")\n        except OSError:\n            # No CSIDL_COMMON_PROGRAMS on this platform\n            fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")\n    else:\n        # non-admin install - always goes in this user's start menu.\n        fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_system_dir",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_system_dir():\n    import win32api  # we assume this exists.\n    try:\n        import pythoncom\n        import win32process\n        from win32com.shell import shell, shellcon\n        try:\n            if win32process.IsWow64Process():\n                return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEMX86)\n            return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEM)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "fixup_dbi",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def fixup_dbi():\n    # We used to have a dbi.pyd with our .pyd files, but now have a .py file.\n    # If the user didn't uninstall, they will find the .pyd which will cause\n    # problems - so handle that.\n    import win32api\n    import win32con\n    pyd_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi.pyd\")\n    pyd_d_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi_d.pyd\")\n    py_name = os.path.join(os.path.dirname(win32con.__file__), \"dbi.py\")\n    for this_pyd in (pyd_name, pyd_d_name):",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "install",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def install(lib_dir):\n    import traceback\n    # The .pth file is now installed as a regular file.\n    # Create the .pth file in the site-packages dir, and use only relative paths\n    # We used to write a .pth directly to sys.prefix - clobber it.\n    if os.path.isfile(os.path.join(sys.prefix, \"pywin32.pth\")):\n        os.unlink(os.path.join(sys.prefix, \"pywin32.pth\"))\n    # The .pth may be new and therefore not loaded in this session.\n    # Setup the paths just in case.\n    for name in \"win32 win32\\\\lib Pythonwin\".split():",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "uninstall",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def uninstall(lib_dir):\n    # First ensure our system modules are loaded from pywin32_system, so\n    # we can remove the ones we copied...\n    LoadSystemModule(lib_dir, \"pywintypes\")\n    LoadSystemModule(lib_dir, \"pythoncom\")\n    try:\n        RegisterCOMObjects(False)\n    except Exception as why:\n        print(f\"Failed to unregister COM objects: {why}\")\n    try:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verify_destination",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def verify_destination(location: str) -> str:\n    location = os.path.abspath(location)\n    if not os.path.isdir(location):\n        raise argparse.ArgumentTypeError(\n            f'Path \"{location}\" is not an existing directory!'\n        )\n    return location\ndef main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:\n    > python -m pywin32_postinstall -install\n    * or (shorter but you don't have control over which python environment is used)\n    > pywin32_postinstall -install\n    You need to execute this script, with a '-install' parameter,\n    to ensure the environment is setup correctly to install COM objects, services, etc.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "tee_f",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "tee_f = open(\n    os.path.join(\n        tempfile.gettempdir(),  # Send output somewhere so it can be found if necessary...\n        \"pywin32_postinstall.log\",\n    ),\n    \"w\",\n)\nclass Tee:\n    def __init__(self, file):\n        self.f = file",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stderr",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stderr = Tee(sys.stderr)\nsys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stdout",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "com_modules",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "com_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0\n# Verbosity of output messages.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "silent",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "silent = 0\n# Verbosity of output messages.\nverbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "verbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "root_key_name",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "root_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()\n    result = subprocess.run(cmd, check=False, cwd=dirname)\n    print(f\"*** Test script '{script}' exited with {result.returncode}\")\n    sys.stdout.flush()\n    if result.returncode:",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "find_and_run",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def find_and_run(possible_locations, extras):\n    for maybe in possible_locations:\n        if os.path.isfile(maybe):\n            run_test(maybe, extras)\n            break\n    else:\n        raise RuntimeError(\n            \"Failed to locate a test script in one of %s\" % possible_locations\n        )\ndef main():",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def main():\n    import argparse\n    code_directories = [project_root] + site_packages\n    parser = argparse.ArgumentParser(\n        description=\"A script to trigger tests in all subprojects of PyWin32.\"\n    )\n    parser.add_argument(\n        \"-no-user-interaction\",\n        default=False,\n        action=\"store_true\",",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "project_root = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))\nsite_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "site_packages",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "site_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "failures",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "failures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "TestBasicConnections",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())\n    def test_remote_connection(self):\n        \"Check that a remote connection works, if specified\"\n        if \"machine\" in settings:\n            self.assert_(wmi.WMI(settings['machine']))\n        else:\n            warnings.warn(\"Skipping test_remote_connection\")",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestThreadedConnection",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestThreadedConnection(unittest.TestCase):\n    def test_initialised_thread(self):\n        \"\"\"A WMI connection in a thread which has been initialised for COM\n        should succeed.\n        \"\"\"\n        def f(q):\n            pythoncom.CoInitialize()\n            try:\n                try:\n                    wmi.WMI()",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestMoniker",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestMoniker(unittest.TestCase):\n    def test_moniker(self):\n        \"\"\"Look at all possible options for moniker construction and pass\n        them through to a WMI connector\n        \"\"\"\n        for computer in COMPUTERS:\n            if computer in (None, \".\"):\n                local_authorities = [None]\n            else:\n                local_authorities = AUTHORITIES",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestFunctions",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestFunctions(unittest.TestCase):\n    times = [\n       ((2000, 1, 1), \"20000101******.******+***\"),\n       ((2000, 1, 1, 10, 0, 0), \"20000101100000.******+***\"),\n       ((2000, 1, 1, 10, 0, 0, 100), \"20000101100000.000100+***\"),\n       ((2000, 1, 1, 10, 0, 0, 100, \"GMT\"), \"20000101100000.000100+GMT\")\n    ]\n    def test_signed_to_unsigned(self):\n        tests = [\n           (0, 0),",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestWMI",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestWMI(unittest.TestCase):\n    def setUp(self):\n        self.connection = wmi.WMI(namespace=\"root/cimv2\", find_classes=False)\n        self.logical_disks = set(self.connection.Win32_LogicalDisk())\nclass TestNamespace(TestWMI):\n    def test_subclasses_of_simple(self):\n        self.assert_(\"Win32_ComputerSystem\" in self.connection.subclasses_of())\n    def test_subclasses_of_subtree(self):\n        self.assert_(\"Win32_Desktop\" in self.connection.subclasses_of(\"CIM_Setting\"))\n    def test_subclasses_of_pattern(self):",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestNamespace",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestNamespace(TestWMI):\n    def test_subclasses_of_simple(self):\n        self.assert_(\"Win32_ComputerSystem\" in self.connection.subclasses_of())\n    def test_subclasses_of_subtree(self):\n        self.assert_(\"Win32_Desktop\" in self.connection.subclasses_of(\"CIM_Setting\"))\n    def test_subclasses_of_pattern(self):\n        self.assert_(set([\"Win32_LogicalDisk\", \"Win32_MappedLogicalDisk\"]) <= set(self.connection.subclasses_of(\"CIM_LogicalDevice\", \"Win32_.*Disk\")))\n    def test_instances(self):\n        self.assertEquals(self.logical_disks, set(self.connection.instances(\"Win32_LogicalDisk\")))\n    def test_new(self):",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestClass",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestClass(TestWMI):\n    def test_class_from_namespace(self):\n        self.assert_(self.connection.Win32_ComputerSystem._namespace is self.connection)\n    def test_class_without_namespace(self):\n        wmi_class = wmi.GetObject(\"winmgmts:Win32_ComputerSystem\")\n        self.assert_(wmi._wmi_class(None, wmi_class)._namespace)\n    def test_query(self):\n        self.assertEquals(\n            set(self.connection.Win32_ComputerSystem.query()),\n            set(self.connection.query(\"SELECT * FROM Win32_ComputerSystem\"))",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestWatcher",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestWatcher(TestWMI):\n    def new_letter(self):\n        return \\\n            set(\"%s:\" % chr(i) for i in range(ord('A'), 1 + ord('Z'))).\\\n            difference(d.DeviceID for d in self.connection.Win32_LogicalDisk()).\\\n            pop()\n    @staticmethod\n    def create(new_letter):\n        #~ print(\"about to create drive with letter\", new_letter)\n        here = os.path.dirname(os.path.abspath(__file__))",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestMethods",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestMethods(TestWMI):\n    def test_exists(self):\n        \"Check that a well-known method is available by attribute\"\n        self.assert_(self.connection.Win32_Process.Create)\n    def test_params(self):\n        \"Check that the names and arrayness of params are picked up when not arrays\"\n        self.assertEquals(\n            [(n, False) for n in [\"CommandLine\", \"CurrentDirectory\", \"ProcessStartupInformation\"]],\n            self.connection.Win32_Process.Create.in_parameter_names\n        )",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestProperties",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestProperties(TestWMI):\n    def test_access(self):\n        \"Check that all properties are available as attributes\"\n        for d in self.logical_disks:\n            break\n        for p in d.ole_object.Properties_:\n            self.assertEqual(p.Value, getattr(d, p.Name))\n    def test_attribute_passthrough(self):\n        \"Check that unknown attributes are passed through to the underlying object\"\n        for d in self.logical_disks:",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestInstances",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestInstances(TestWMI):\n    def test_hashable(self):\n        \"Ensure instances are hashable so can be used in a set/dict\"\n        self.assert_(dict.fromkeys(self.logical_disks))\n    def test_equalable(self):\n        \"Ensure instances compare equal\"\n        self.assertEqual(self.logical_disks, self.logical_disks)\n    def test_not_equal_to_anything_else(self):\n        \"Ensure WMI instances are not equal to non-WMI instances\"\n        for d in self.logical_disks:",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestInstanceCreation",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestInstanceCreation(TestWMI):\n    def test_create_instance(self):\n        self.assert_(isinstance(self.connection.Win32_ProcessStartup.new(ShowWindow=2), wmi._wmi_object))\nclass TestAssociations(TestWMI):\n    def test_all_properties_available(self):\n        #\n        # An association can contain not only the associated\n        # classes but also extra information as well. Ensure\n        # that both types of data are correctly handled.\n        #",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestAssociations",
        "kind": 6,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "class TestAssociations(TestWMI):\n    def test_all_properties_available(self):\n        #\n        # An association can contain not only the associated\n        # classes but also extra information as well. Ensure\n        # that both types of data are correctly handled.\n        #\n        for q in self.connection.Win32_DiskQuota():\n            for p in q.properties:\n                try:",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "ini",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "ini = ConfigParser.SafeConfigParser()\nini.read([\"wmitest.master.ini\", \"wmitest.ini\"])\nsettings = {}\nif ini.has_section(\"settings\"):\n    settings.update(ini.items(\"settings\"))\nexcludes = [i.strip() for i in settings.get(\"excludes\", \"\").split(\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "settings",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "settings = {}\nif ini.has_section(\"settings\"):\n    settings.update(ini.items(\"settings\"))\nexcludes = [i.strip() for i in settings.get(\"excludes\", \"\").split(\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "excludes",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "excludes = [i.strip() for i in settings.get(\"excludes\", \"\").split(\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "COMPUTERS",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "COMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "IMPERSONATION_LEVELS",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "IMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "AUTHENTICATION_LEVELS",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "AUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "AUTHORITIES",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "AUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "PRIVILEGES",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "PRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())\n    def test_remote_connection(self):\n        \"Check that a remote connection works, if specified\"\n        if \"machine\" in settings:\n            self.assert_(wmi.WMI(settings['machine']))",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "NAMESPACES",
        "kind": 5,
        "importPath": ".venv.Scripts.wmitest",
        "description": ".venv.Scripts.wmitest",
        "peekOfCode": "NAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())\n    def test_remote_connection(self):\n        \"Check that a remote connection works, if specified\"\n        if \"machine\" in settings:\n            self.assert_(wmi.WMI(settings['machine']))\n        else:",
        "detail": ".venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "link",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def link(text, computer, namespace=None, wmi_class=None):\n    link = '<a href=\"/' + quote(computer)\n    if namespace:\n        link += \"/\" + quote(namespace)\n    if wmi_class:\n        link += \"/\" + quote(wmi_class)\n    return link + '\">' + escape(text) + '</a>'\ndef start_doc(title):\n    doc[:] = []\n    doc.append(\"\"\"",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "start_doc",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def start_doc(title):\n    doc[:] = []\n    doc.append(\"\"\"\n    <html>\n    <head>\n    <title>%(title)s</title>\n    <style>\n    body {font-family : Verdana, sans-serif; font-size : 84%%; margin : 3em;}\n    table.items {padding-left : 30px;}\n    li, td {font-family : \"Courier New\", monospace;}",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "finish_doc",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def finish_doc():\n    doc.append(\"\"\"\n    </body>\n    </html>\n    \"\"\" % locals())\ndef doc_table(items, n_cols=3, callback=None):\n    n_rows, n_spare_cols = divmod(len(items), n_cols)\n    doc.append('<table cellspacing=0 class=\"items\">')\n    for n_row in range(n_rows):\n        doc.append(\"<tr>\")",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_table",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def doc_table(items, n_cols=3, callback=None):\n    n_rows, n_spare_cols = divmod(len(items), n_cols)\n    doc.append('<table cellspacing=0 class=\"items\">')\n    for n_row in range(n_rows):\n        doc.append(\"<tr>\")\n        for n_col in range(n_cols):\n            item = items[n_cols * n_col + n_row]\n            if callback:\n                item = callback(item)\n            doc.append(\"<td><li>%s</li></td>\" % item)",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_breadcrumbs",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def doc_breadcrumbs(computer, namespace, wmi_class=None):\n    doc.append('<p class=\"breadcrumbs\">')\n    doc.append('%s &rarr; %s' % (link(computer, computer), link(namespace, computer, namespace)))\n    if wmi_class:\n        doc.append(' &rarr; %s' % (link(wmi_class, computer, namespace, wmi_class)))\n    doc.append('</p>')\ndef doc_wmi_class(computer, namespace, wmi_class, wmi_connection):\n    start_doc(\"WMI: Class %(wmi_class)s in namespace %(namespace)s on %(computer)s\" % locals())\n    doc_breadcrumbs(computer, namespace, wmi_class)\n    doc.append(\"<h2>%(wmi_class)s</h2>\" % locals())",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_wmi_class",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def doc_wmi_class(computer, namespace, wmi_class, wmi_connection):\n    start_doc(\"WMI: Class %(wmi_class)s in namespace %(namespace)s on %(computer)s\" % locals())\n    doc_breadcrumbs(computer, namespace, wmi_class)\n    doc.append(\"<h2>%(wmi_class)s</h2>\" % locals())\n    klass = getattr(wmi_connection, wmi_class)\n    def property_callback(property_name):\n        property = klass.wmi_property(property_name)\n        mapping = property.qualifiers.get(\"MappingStrings\")\n        if mapping is None:\n            return property_name",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_namespace",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def doc_namespace(computer, namespace, wmi_connection):\n    start_doc(\"WMI: Namespace %(namespace)s on %(computer)s\" % locals())\n    doc_breadcrumbs(computer, namespace)\n    namespaces = namespace.split(\"\\\\\")\n    namespace_links = []\n    for i, n in enumerate(namespaces):\n        namespace_links.append(link(n, computer, \"\\\\\".join(namespaces[:i+1])))\n    doc.append(\"<h2>%s</h2>\" % \"\\\\\".join(namespace_links))\n    doc.append(\"<hr>\")\n    subnamespaces = sorted(wmi_connection.__NAMESPACE())",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "handle_namespace",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def handle_namespace(environ, computer, namespace):\n    if not namespace:\n        wmi_connection = wmi.WMI(computer, namespace=\"root/cimv2\")\n        for setting in wmi_connection.Win32_WMISetting():\n            namespace=setting.ASPScriptDefaultNamespace\n            break\n    wmi_connection = wmi.WMI(computer, namespace=namespace, find_classes=True)\n    wmi_class = shift_path_info(environ)\n    if wmi_class:\n        doc_wmi_class(computer, namespace, wmi_class, wmi_connection)",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "handle_computer",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def handle_computer(environ, computer):\n    handle_namespace(environ, computer, shift_path_info(environ))\ndef app(environ, start_response):\n    computer = shift_path_info(environ)\n    if computer == \"favicon.ico\":\n        start_response(\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n        return []\n    elif computer:\n        start_response(\"200 OK\", [(\"Content-Type\", \"text/html; charset=utf-8\")])\n        handle_computer(environ, computer)",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def app(environ, start_response):\n    computer = shift_path_info(environ)\n    if computer == \"favicon.ico\":\n        start_response(\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n        return []\n    elif computer:\n        start_response(\"200 OK\", [(\"Content-Type\", \"text/html; charset=utf-8\")])\n        handle_computer(environ, computer)\n        return(unicode(d).encode(\"utf8\") + unicode(\"\\n\").encode(\"utf8\") for d in doc)\n    else:",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "run_browser",
        "kind": 2,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "def run_browser():\n    import os\n    os.startfile(\"http://localhost:%d\" % PORT)\nif __name__ == '__main__':\n    threading.Timer(3.0, run_browser).start()\n    httpd = make_server('', PORT, app)\n    try:\n        httpd.serve_forever()\n    except KeyboardInterrupt:\n        print(\"Shutting down gracefully...\")",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc",
        "kind": 5,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "doc = []\ndef link(text, computer, namespace=None, wmi_class=None):\n    link = '<a href=\"/' + quote(computer)\n    if namespace:\n        link += \"/\" + quote(namespace)\n    if wmi_class:\n        link += \"/\" + quote(wmi_class)\n    return link + '\">' + escape(text) + '</a>'\ndef start_doc(title):\n    doc[:] = []",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".venv.Scripts.wmiweb",
        "description": ".venv.Scripts.wmiweb",
        "peekOfCode": "PORT = 8010\ndef run_browser():\n    import os\n    os.startfile(\"http://localhost:%d\" % PORT)\nif __name__ == '__main__':\n    threading.Timer(3.0, run_browser).start()\n    httpd = make_server('', PORT, app)\n    try:\n        httpd.serve_forever()\n    except KeyboardInterrupt:",
        "detail": ".venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.ai.aggregator",
        "description": "modes.ai.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for ai monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.ai.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.ai.aggregator",
        "description": "modes.ai.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.ai.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.ai.aggregator",
        "description": "modes.ai.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.ai.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.ai.aggregator",
        "description": "modes.ai.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for ai monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.ai.aggregator",
        "documentation": {}
    },
    {
        "label": "get_autonomous_control",
        "kind": 2,
        "importPath": "modes.ai.autonomous_control",
        "description": "modes.ai.autonomous_control",
        "peekOfCode": "def get_autonomous_control():\n    \"\"\"Get status of autonomous control system\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Check if there's an active control session\n        active_session = _get_active_session()\n        # Get control capabilities\n        capabilities = _get_control_capabilities()\n        # Get recent control history",
        "detail": "modes.ai.autonomous_control",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "modes.ai.autonomous_control",
        "description": "modes.ai.autonomous_control",
        "peekOfCode": "DATA_DIR = Path(__file__).parent / \"data\"\nCONTROL_LOG = DATA_DIR / \"control_sessions.json\"\nACTIVE_SESSION = DATA_DIR / \"active_session.json\"\ndef get_autonomous_control():\n    \"\"\"Get status of autonomous control system\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Check if there's an active control session\n        active_session = _get_active_session()",
        "detail": "modes.ai.autonomous_control",
        "documentation": {}
    },
    {
        "label": "CONTROL_LOG",
        "kind": 5,
        "importPath": "modes.ai.autonomous_control",
        "description": "modes.ai.autonomous_control",
        "peekOfCode": "CONTROL_LOG = DATA_DIR / \"control_sessions.json\"\nACTIVE_SESSION = DATA_DIR / \"active_session.json\"\ndef get_autonomous_control():\n    \"\"\"Get status of autonomous control system\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Check if there's an active control session\n        active_session = _get_active_session()\n        # Get control capabilities",
        "detail": "modes.ai.autonomous_control",
        "documentation": {}
    },
    {
        "label": "ACTIVE_SESSION",
        "kind": 5,
        "importPath": "modes.ai.autonomous_control",
        "description": "modes.ai.autonomous_control",
        "peekOfCode": "ACTIVE_SESSION = DATA_DIR / \"active_session.json\"\ndef get_autonomous_control():\n    \"\"\"Get status of autonomous control system\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Check if there's an active control session\n        active_session = _get_active_session()\n        # Get control capabilities\n        capabilities = _get_control_capabilities()",
        "detail": "modes.ai.autonomous_control",
        "documentation": {}
    },
    {
        "label": "get_decision_engine",
        "kind": 2,
        "importPath": "modes.ai.decision_engine",
        "description": "modes.ai.decision_engine",
        "peekOfCode": "def get_decision_engine():\n    \"\"\"Make decisions based on current system state and predictions\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load decision rules\n        rules = _load_decision_rules()\n        # Make decisions based on current state\n        decisions = _make_decisions(rules)\n        # Save decisions",
        "detail": "modes.ai.decision_engine",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "modes.ai.decision_engine",
        "description": "modes.ai.decision_engine",
        "peekOfCode": "DATA_DIR = Path(__file__).parent / \"data\"\nDECISIONS_FILE = DATA_DIR / \"decisions.json\"\nRULES_FILE = DATA_DIR / \"decision_rules.json\"\ndef get_decision_engine():\n    \"\"\"Make decisions based on current system state and predictions\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load decision rules\n        rules = _load_decision_rules()",
        "detail": "modes.ai.decision_engine",
        "documentation": {}
    },
    {
        "label": "DECISIONS_FILE",
        "kind": 5,
        "importPath": "modes.ai.decision_engine",
        "description": "modes.ai.decision_engine",
        "peekOfCode": "DECISIONS_FILE = DATA_DIR / \"decisions.json\"\nRULES_FILE = DATA_DIR / \"decision_rules.json\"\ndef get_decision_engine():\n    \"\"\"Make decisions based on current system state and predictions\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load decision rules\n        rules = _load_decision_rules()\n        # Make decisions based on current state",
        "detail": "modes.ai.decision_engine",
        "documentation": {}
    },
    {
        "label": "RULES_FILE",
        "kind": 5,
        "importPath": "modes.ai.decision_engine",
        "description": "modes.ai.decision_engine",
        "peekOfCode": "RULES_FILE = DATA_DIR / \"decision_rules.json\"\ndef get_decision_engine():\n    \"\"\"Make decisions based on current system state and predictions\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load decision rules\n        rules = _load_decision_rules()\n        # Make decisions based on current state\n        decisions = _make_decisions(rules)",
        "detail": "modes.ai.decision_engine",
        "documentation": {}
    },
    {
        "label": "get_habit_analyzer",
        "kind": 2,
        "importPath": "modes.ai.habit_analyzer",
        "description": "modes.ai.habit_analyzer",
        "peekOfCode": "def get_habit_analyzer():\n    \"\"\"Analyze user habits from collected monitoring data\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        if not HABITS_FILE.exists():\n            return {\n                \"status\": \"no_data\",\n                \"message\": \"No habit data collected yet. Start monitoring to build patterns.\"\n            }",
        "detail": "modes.ai.habit_analyzer",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "modes.ai.habit_analyzer",
        "description": "modes.ai.habit_analyzer",
        "peekOfCode": "DATA_DIR = Path(__file__).parent / \"data\"\nHABITS_FILE = DATA_DIR / \"user_habits.json\"\ndef get_habit_analyzer():\n    \"\"\"Analyze user habits from collected monitoring data\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        if not HABITS_FILE.exists():\n            return {\n                \"status\": \"no_data\",",
        "detail": "modes.ai.habit_analyzer",
        "documentation": {}
    },
    {
        "label": "HABITS_FILE",
        "kind": 5,
        "importPath": "modes.ai.habit_analyzer",
        "description": "modes.ai.habit_analyzer",
        "peekOfCode": "HABITS_FILE = DATA_DIR / \"user_habits.json\"\ndef get_habit_analyzer():\n    \"\"\"Analyze user habits from collected monitoring data\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        if not HABITS_FILE.exists():\n            return {\n                \"status\": \"no_data\",\n                \"message\": \"No habit data collected yet. Start monitoring to build patterns.\"",
        "detail": "modes.ai.habit_analyzer",
        "documentation": {}
    },
    {
        "label": "get_learning_engine",
        "kind": 2,
        "importPath": "modes.ai.learning_engine",
        "description": "modes.ai.learning_engine",
        "peekOfCode": "def get_learning_engine():\n    \"\"\"Get status and insights from the learning engine\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load learning data\n        learning_data = _load_learning_data()\n        # Process recent observations\n        insights = _process_learning_data(learning_data)\n        # Update model state",
        "detail": "modes.ai.learning_engine",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "modes.ai.learning_engine",
        "description": "modes.ai.learning_engine",
        "peekOfCode": "DATA_DIR = Path(__file__).parent / \"data\"\nLEARNING_DATA = DATA_DIR / \"learning_data.json\"\nMODEL_STATE = DATA_DIR / \"model_state.json\"\ndef get_learning_engine():\n    \"\"\"Get status and insights from the learning engine\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load learning data\n        learning_data = _load_learning_data()",
        "detail": "modes.ai.learning_engine",
        "documentation": {}
    },
    {
        "label": "LEARNING_DATA",
        "kind": 5,
        "importPath": "modes.ai.learning_engine",
        "description": "modes.ai.learning_engine",
        "peekOfCode": "LEARNING_DATA = DATA_DIR / \"learning_data.json\"\nMODEL_STATE = DATA_DIR / \"model_state.json\"\ndef get_learning_engine():\n    \"\"\"Get status and insights from the learning engine\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load learning data\n        learning_data = _load_learning_data()\n        # Process recent observations",
        "detail": "modes.ai.learning_engine",
        "documentation": {}
    },
    {
        "label": "MODEL_STATE",
        "kind": 5,
        "importPath": "modes.ai.learning_engine",
        "description": "modes.ai.learning_engine",
        "peekOfCode": "MODEL_STATE = DATA_DIR / \"model_state.json\"\ndef get_learning_engine():\n    \"\"\"Get status and insights from the learning engine\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load learning data\n        learning_data = _load_learning_data()\n        # Process recent observations\n        insights = _process_learning_data(learning_data)",
        "detail": "modes.ai.learning_engine",
        "documentation": {}
    },
    {
        "label": "get_pattern_recognition",
        "kind": 2,
        "importPath": "modes.ai.pattern_recognition",
        "description": "modes.ai.pattern_recognition",
        "peekOfCode": "def get_pattern_recognition():\n    \"\"\"Recognize patterns in user behavior and system usage\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load existing patterns or create new\n        if PATTERNS_FILE.exists():\n            with open(PATTERNS_FILE, 'r') as f:\n                patterns = json.load(f)\n        else:",
        "detail": "modes.ai.pattern_recognition",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "modes.ai.pattern_recognition",
        "description": "modes.ai.pattern_recognition",
        "peekOfCode": "DATA_DIR = Path(__file__).parent / \"data\"\nPATTERNS_FILE = DATA_DIR / \"recognized_patterns.json\"\ndef get_pattern_recognition():\n    \"\"\"Recognize patterns in user behavior and system usage\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load existing patterns or create new\n        if PATTERNS_FILE.exists():\n            with open(PATTERNS_FILE, 'r') as f:",
        "detail": "modes.ai.pattern_recognition",
        "documentation": {}
    },
    {
        "label": "PATTERNS_FILE",
        "kind": 5,
        "importPath": "modes.ai.pattern_recognition",
        "description": "modes.ai.pattern_recognition",
        "peekOfCode": "PATTERNS_FILE = DATA_DIR / \"recognized_patterns.json\"\ndef get_pattern_recognition():\n    \"\"\"Recognize patterns in user behavior and system usage\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load existing patterns or create new\n        if PATTERNS_FILE.exists():\n            with open(PATTERNS_FILE, 'r') as f:\n                patterns = json.load(f)",
        "detail": "modes.ai.pattern_recognition",
        "documentation": {}
    },
    {
        "label": "get_predictive_analysis",
        "kind": 2,
        "importPath": "modes.ai.predictive_analysis",
        "description": "modes.ai.predictive_analysis",
        "peekOfCode": "def get_predictive_analysis():\n    \"\"\"Generate predictions based on historical data and patterns\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load historical data for predictions\n        predictions = _generate_predictions()\n        # Save predictions\n        prediction_data = {\n            \"predictions\": predictions,",
        "detail": "modes.ai.predictive_analysis",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "modes.ai.predictive_analysis",
        "description": "modes.ai.predictive_analysis",
        "peekOfCode": "DATA_DIR = Path(__file__).parent / \"data\"\nPREDICTIONS_FILE = DATA_DIR / \"predictions.json\"\nHISTORY_FILE = DATA_DIR / \"prediction_history.json\"\ndef get_predictive_analysis():\n    \"\"\"Generate predictions based on historical data and patterns\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load historical data for predictions\n        predictions = _generate_predictions()",
        "detail": "modes.ai.predictive_analysis",
        "documentation": {}
    },
    {
        "label": "PREDICTIONS_FILE",
        "kind": 5,
        "importPath": "modes.ai.predictive_analysis",
        "description": "modes.ai.predictive_analysis",
        "peekOfCode": "PREDICTIONS_FILE = DATA_DIR / \"predictions.json\"\nHISTORY_FILE = DATA_DIR / \"prediction_history.json\"\ndef get_predictive_analysis():\n    \"\"\"Generate predictions based on historical data and patterns\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load historical data for predictions\n        predictions = _generate_predictions()\n        # Save predictions",
        "detail": "modes.ai.predictive_analysis",
        "documentation": {}
    },
    {
        "label": "HISTORY_FILE",
        "kind": 5,
        "importPath": "modes.ai.predictive_analysis",
        "description": "modes.ai.predictive_analysis",
        "peekOfCode": "HISTORY_FILE = DATA_DIR / \"prediction_history.json\"\ndef get_predictive_analysis():\n    \"\"\"Generate predictions based on historical data and patterns\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load historical data for predictions\n        predictions = _generate_predictions()\n        # Save predictions\n        prediction_data = {",
        "detail": "modes.ai.predictive_analysis",
        "documentation": {}
    },
    {
        "label": "get_query_processor",
        "kind": 2,
        "importPath": "modes.ai.query_processor",
        "description": "modes.ai.query_processor",
        "peekOfCode": "def get_query_processor():\n    \"\"\"Process natural language queries about system state and user habits\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Get query processing capabilities\n        capabilities = _get_query_capabilities()\n        # Get recent query history\n        history = _get_query_history()\n        return {",
        "detail": "modes.ai.query_processor",
        "documentation": {}
    },
    {
        "label": "process_query",
        "kind": 2,
        "importPath": "modes.ai.query_processor",
        "description": "modes.ai.query_processor",
        "peekOfCode": "def process_query(query_text):\n    \"\"\"Process a specific query and return analysis\"\"\"\n    try:\n        query_text = query_text.lower().strip()\n        # Log the query\n        _log_query(query_text)\n        # Determine query type\n        query_type = _classify_query(query_text)\n        # Process based on type\n        response = _generate_response(query_text, query_type)",
        "detail": "modes.ai.query_processor",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "modes.ai.query_processor",
        "description": "modes.ai.query_processor",
        "peekOfCode": "DATA_DIR = Path(__file__).parent / \"data\"\nQUERY_LOG = DATA_DIR / \"query_log.json\"\ndef get_query_processor():\n    \"\"\"Process natural language queries about system state and user habits\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Get query processing capabilities\n        capabilities = _get_query_capabilities()\n        # Get recent query history",
        "detail": "modes.ai.query_processor",
        "documentation": {}
    },
    {
        "label": "QUERY_LOG",
        "kind": 5,
        "importPath": "modes.ai.query_processor",
        "description": "modes.ai.query_processor",
        "peekOfCode": "QUERY_LOG = DATA_DIR / \"query_log.json\"\ndef get_query_processor():\n    \"\"\"Process natural language queries about system state and user habits\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Get query processing capabilities\n        capabilities = _get_query_capabilities()\n        # Get recent query history\n        history = _get_query_history()",
        "detail": "modes.ai.query_processor",
        "documentation": {}
    },
    {
        "label": "get_active_window",
        "kind": 2,
        "importPath": "modes.applications.active_window",
        "description": "modes.applications.active_window",
        "peekOfCode": "def get_active_window():\n    \"\"\"Get currently active window information\"\"\"\n    try:\n        if platform.system() == \"Windows\":\n            try:\n                import win32gui\n                hwnd = win32gui.GetForegroundWindow()\n                window_title = win32gui.GetWindowText(hwnd)\n                return {\n                    \"title\": window_title,",
        "detail": "modes.applications.active_window",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.applications.aggregator",
        "description": "modes.applications.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for applications monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.applications.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.applications.aggregator",
        "description": "modes.applications.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.applications.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.applications.aggregator",
        "description": "modes.applications.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.applications.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.applications.aggregator",
        "description": "modes.applications.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for applications monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.applications.aggregator",
        "documentation": {}
    },
    {
        "label": "get_app_usage",
        "kind": 2,
        "importPath": "modes.applications.app_usage",
        "description": "modes.applications.app_usage",
        "peekOfCode": "def get_app_usage():\n    \"\"\"Get per-application resource usage\"\"\"\n    try:\n        apps = {}\n        for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent', 'memory_info']):\n            try:\n                name = proc.info['name']\n                if name not in apps:\n                    apps[name] = {\n                        \"instances\": 0,",
        "detail": "modes.applications.app_usage",
        "documentation": {}
    },
    {
        "label": "get_browser_tabs",
        "kind": 2,
        "importPath": "modes.applications.browser_tabs",
        "description": "modes.applications.browser_tabs",
        "peekOfCode": "def get_browser_tabs():\n    \"\"\"Estimate browser tab usage by process count\"\"\"\n    try:\n        browsers = {\n            \"chrome.exe\": 0,\n            \"firefox.exe\": 0,\n            \"msedge.exe\": 0,\n            \"opera.exe\": 0,\n            \"brave.exe\": 0,\n            \"safari\": 0",
        "detail": "modes.applications.browser_tabs",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.audio.aggregator",
        "description": "modes.audio.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for audio monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.audio.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.audio.aggregator",
        "description": "modes.audio.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.audio.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.audio.aggregator",
        "description": "modes.audio.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.audio.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.audio.aggregator",
        "description": "modes.audio.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for audio monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.audio.aggregator",
        "documentation": {}
    },
    {
        "label": "get_audio_levels",
        "kind": 2,
        "importPath": "modes.audio.audio_levels",
        "description": "modes.audio.audio_levels",
        "peekOfCode": "def get_audio_levels():\n    \"\"\"Get current audio input/output levels\"\"\"\n    try:\n        # Simulate audio level monitoring (real implementation would use pyaudio or similar)\n        current_time = time.time()\n        # Simulate microphone and speaker levels\n        import random\n        mic_level = random.uniform(0, 100) if random.random() > 0.7 else 0  # 30% chance of activity\n        speaker_level = random.uniform(0, 100) if random.random() > 0.5 else 0  # 50% chance of activity\n        audio_data = {",
        "detail": "modes.audio.audio_levels",
        "documentation": {}
    },
    {
        "label": "AUDIO_LOG",
        "kind": 5,
        "importPath": "modes.audio.audio_levels",
        "description": "modes.audio.audio_levels",
        "peekOfCode": "AUDIO_LOG = Path(__file__).parent / \"audio_levels.json\"\ndef get_audio_levels():\n    \"\"\"Get current audio input/output levels\"\"\"\n    try:\n        # Simulate audio level monitoring (real implementation would use pyaudio or similar)\n        current_time = time.time()\n        # Simulate microphone and speaker levels\n        import random\n        mic_level = random.uniform(0, 100) if random.random() > 0.7 else 0  # 30% chance of activity\n        speaker_level = random.uniform(0, 100) if random.random() > 0.5 else 0  # 50% chance of activity",
        "detail": "modes.audio.audio_levels",
        "documentation": {}
    },
    {
        "label": "get_audio_optimization",
        "kind": 2,
        "importPath": "modes.audio.audio_optimization",
        "description": "modes.audio.audio_optimization",
        "peekOfCode": "def get_audio_optimization():\n    \"\"\"Get audio optimization capabilities and current settings\"\"\"\n    try:\n        if not PROFILES_DIR.exists():\n            PROFILES_DIR.mkdir(exist_ok=True)\n        # Load optimization profiles\n        profiles = _load_audio_profiles()\n        current_optimization = _get_current_optimization()\n        return {\n            \"status\": \"optimizing\",",
        "detail": "modes.audio.audio_optimization",
        "documentation": {}
    },
    {
        "label": "OPTIMIZATION_LOG",
        "kind": 5,
        "importPath": "modes.audio.audio_optimization",
        "description": "modes.audio.audio_optimization",
        "peekOfCode": "OPTIMIZATION_LOG = Path(__file__).parent / \"audio_optimization.json\"\nPROFILES_DIR = Path(__file__).parent / \"audio_profiles\"\ndef get_audio_optimization():\n    \"\"\"Get audio optimization capabilities and current settings\"\"\"\n    try:\n        if not PROFILES_DIR.exists():\n            PROFILES_DIR.mkdir(exist_ok=True)\n        # Load optimization profiles\n        profiles = _load_audio_profiles()\n        current_optimization = _get_current_optimization()",
        "detail": "modes.audio.audio_optimization",
        "documentation": {}
    },
    {
        "label": "PROFILES_DIR",
        "kind": 5,
        "importPath": "modes.audio.audio_optimization",
        "description": "modes.audio.audio_optimization",
        "peekOfCode": "PROFILES_DIR = Path(__file__).parent / \"audio_profiles\"\ndef get_audio_optimization():\n    \"\"\"Get audio optimization capabilities and current settings\"\"\"\n    try:\n        if not PROFILES_DIR.exists():\n            PROFILES_DIR.mkdir(exist_ok=True)\n        # Load optimization profiles\n        profiles = _load_audio_profiles()\n        current_optimization = _get_current_optimization()\n        return {",
        "detail": "modes.audio.audio_optimization",
        "documentation": {}
    },
    {
        "label": "get_device_manager",
        "kind": 2,
        "importPath": "modes.audio.device_manager",
        "description": "modes.audio.device_manager",
        "peekOfCode": "def get_device_manager():\n    \"\"\"Get audio device information and management capabilities\"\"\"\n    try:\n        devices = _get_audio_devices()\n        return {\n            \"status\": \"active\",\n            \"available_devices\": devices,\n            \"device_count\": len(devices),\n            \"platform\": platform.system(),\n            \"capabilities\": {",
        "detail": "modes.audio.device_manager",
        "documentation": {}
    },
    {
        "label": "DEVICE_LOG",
        "kind": 5,
        "importPath": "modes.audio.device_manager",
        "description": "modes.audio.device_manager",
        "peekOfCode": "DEVICE_LOG = Path(__file__).parent / \"audio_devices.json\"\ndef get_device_manager():\n    \"\"\"Get audio device information and management capabilities\"\"\"\n    try:\n        devices = _get_audio_devices()\n        return {\n            \"status\": \"active\",\n            \"available_devices\": devices,\n            \"device_count\": len(devices),\n            \"platform\": platform.system(),",
        "detail": "modes.audio.device_manager",
        "documentation": {}
    },
    {
        "label": "get_meeting_audio",
        "kind": 2,
        "importPath": "modes.audio.meeting_audio",
        "description": "modes.audio.meeting_audio",
        "peekOfCode": "def get_meeting_audio():\n    \"\"\"Get meeting audio analysis and optimization\"\"\"\n    try:\n        # Detect if meeting software is running\n        meeting_status = _detect_meeting_software()\n        # Analyze current meeting audio if active\n        if meeting_status[\"meeting_active\"]:\n            audio_analysis = _analyze_meeting_audio()\n        else:\n            audio_analysis = {\"status\": \"no_meeting_detected\"}",
        "detail": "modes.audio.meeting_audio",
        "documentation": {}
    },
    {
        "label": "MEETING_LOG",
        "kind": 5,
        "importPath": "modes.audio.meeting_audio",
        "description": "modes.audio.meeting_audio",
        "peekOfCode": "MEETING_LOG = Path(__file__).parent / \"meeting_audio.json\"\ndef get_meeting_audio():\n    \"\"\"Get meeting audio analysis and optimization\"\"\"\n    try:\n        # Detect if meeting software is running\n        meeting_status = _detect_meeting_software()\n        # Analyze current meeting audio if active\n        if meeting_status[\"meeting_active\"]:\n            audio_analysis = _analyze_meeting_audio()\n        else:",
        "detail": "modes.audio.meeting_audio",
        "documentation": {}
    },
    {
        "label": "get_sound_analysis",
        "kind": 2,
        "importPath": "modes.audio.sound_analysis",
        "description": "modes.audio.sound_analysis",
        "peekOfCode": "def get_sound_analysis():\n    \"\"\"Get advanced sound analysis capabilities\"\"\"\n    try:\n        # Simulate sound analysis data\n        current_analysis = _generate_sound_analysis()\n        return {\n            \"status\": \"analyzing\",\n            \"current_analysis\": current_analysis,\n            \"analysis_capabilities\": {\n                \"frequency_analysis\": {",
        "detail": "modes.audio.sound_analysis",
        "documentation": {}
    },
    {
        "label": "ANALYSIS_LOG",
        "kind": 5,
        "importPath": "modes.audio.sound_analysis",
        "description": "modes.audio.sound_analysis",
        "peekOfCode": "ANALYSIS_LOG = Path(__file__).parent / \"sound_analysis.json\"\ndef get_sound_analysis():\n    \"\"\"Get advanced sound analysis capabilities\"\"\"\n    try:\n        # Simulate sound analysis data\n        current_analysis = _generate_sound_analysis()\n        return {\n            \"status\": \"analyzing\",\n            \"current_analysis\": current_analysis,\n            \"analysis_capabilities\": {",
        "detail": "modes.audio.sound_analysis",
        "documentation": {}
    },
    {
        "label": "get_voice_activity",
        "kind": 2,
        "importPath": "modes.audio.voice_activity",
        "description": "modes.audio.voice_activity",
        "peekOfCode": "def get_voice_activity():\n    \"\"\"Get voice activity detection status and analysis\"\"\"\n    try:\n        # Simulate voice activity detection\n        current_activity = _detect_voice_activity()\n        # Load historical data\n        if VOICE_LOG.exists():\n            with open(VOICE_LOG, 'r') as f:\n                voice_data = json.load(f)\n        else:",
        "detail": "modes.audio.voice_activity",
        "documentation": {}
    },
    {
        "label": "VOICE_LOG",
        "kind": 5,
        "importPath": "modes.audio.voice_activity",
        "description": "modes.audio.voice_activity",
        "peekOfCode": "VOICE_LOG = Path(__file__).parent / \"voice_activity.json\"\ndef get_voice_activity():\n    \"\"\"Get voice activity detection status and analysis\"\"\"\n    try:\n        # Simulate voice activity detection\n        current_activity = _detect_voice_activity()\n        # Load historical data\n        if VOICE_LOG.exists():\n            with open(VOICE_LOG, 'r') as f:\n                voice_data = json.load(f)",
        "detail": "modes.audio.voice_activity",
        "documentation": {}
    },
    {
        "label": "get_action_replay",
        "kind": 2,
        "importPath": "modes.automation.action_replay",
        "description": "modes.automation.action_replay",
        "peekOfCode": "def get_action_replay():\n    \"\"\"Get available recordings and replay capabilities\"\"\"\n    try:\n        if not RECORDINGS_DIR.exists():\n            RECORDINGS_DIR.mkdir(exist_ok=True)\n            return {\"recordings\": [], \"status\": \"no_recordings\"}\n        recordings = []\n        for file in RECORDINGS_DIR.glob(\"*.json\"):\n            try:\n                with open(file, 'r') as f:",
        "detail": "modes.automation.action_replay",
        "documentation": {}
    },
    {
        "label": "RECORDINGS_DIR",
        "kind": 5,
        "importPath": "modes.automation.action_replay",
        "description": "modes.automation.action_replay",
        "peekOfCode": "RECORDINGS_DIR = Path(__file__).parent / \"recordings\"\ndef get_action_replay():\n    \"\"\"Get available recordings and replay capabilities\"\"\"\n    try:\n        if not RECORDINGS_DIR.exists():\n            RECORDINGS_DIR.mkdir(exist_ok=True)\n            return {\"recordings\": [], \"status\": \"no_recordings\"}\n        recordings = []\n        for file in RECORDINGS_DIR.glob(\"*.json\"):\n            try:",
        "detail": "modes.automation.action_replay",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.automation.aggregator",
        "description": "modes.automation.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for automation monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.automation.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.automation.aggregator",
        "description": "modes.automation.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.automation.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.automation.aggregator",
        "description": "modes.automation.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.automation.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.automation.aggregator",
        "description": "modes.automation.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for automation monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.automation.aggregator",
        "documentation": {}
    },
    {
        "label": "MacroRecorder",
        "kind": 6,
        "importPath": "modes.automation.macro_recorder",
        "description": "modes.automation.macro_recorder",
        "peekOfCode": "class MacroRecorder:\n    def __init__(self):\n        self.recording = False\n        self.actions = []\n        self.start_time = None\n    def start_recording(self):\n        \"\"\"Start recording user actions\"\"\"\n        self.recording = True\n        self.actions = []\n        self.start_time = time.time()",
        "detail": "modes.automation.macro_recorder",
        "documentation": {}
    },
    {
        "label": "start_macro_recording",
        "kind": 2,
        "importPath": "modes.automation.macro_recorder",
        "description": "modes.automation.macro_recorder",
        "peekOfCode": "def start_macro_recording():\n    \"\"\"Start recording a macro\"\"\"\n    try:\n        return _recorder.start_recording()\n    except Exception as e:\n        return {\"error\": str(e)}\ndef stop_macro_recording():\n    \"\"\"Stop recording a macro\"\"\"\n    try:\n        return _recorder.stop_recording()",
        "detail": "modes.automation.macro_recorder",
        "documentation": {}
    },
    {
        "label": "stop_macro_recording",
        "kind": 2,
        "importPath": "modes.automation.macro_recorder",
        "description": "modes.automation.macro_recorder",
        "peekOfCode": "def stop_macro_recording():\n    \"\"\"Stop recording a macro\"\"\"\n    try:\n        return _recorder.stop_recording()\n    except Exception as e:\n        return {\"error\": str(e)}\ndef save_macro(macro_name, description=\"\"):\n    \"\"\"Save recorded macro to file\"\"\"\n    try:\n        if _recorder.recording:",
        "detail": "modes.automation.macro_recorder",
        "documentation": {}
    },
    {
        "label": "save_macro",
        "kind": 2,
        "importPath": "modes.automation.macro_recorder",
        "description": "modes.automation.macro_recorder",
        "peekOfCode": "def save_macro(macro_name, description=\"\"):\n    \"\"\"Save recorded macro to file\"\"\"\n    try:\n        if _recorder.recording:\n            return {\"error\": \"Cannot save macro while recording is active\"}\n        if not _recorder.actions:\n            return {\"error\": \"No actions recorded\"}\n        macro_data = {\n            \"name\": macro_name,\n            \"description\": description,",
        "detail": "modes.automation.macro_recorder",
        "documentation": {}
    },
    {
        "label": "load_macro",
        "kind": 2,
        "importPath": "modes.automation.macro_recorder",
        "description": "modes.automation.macro_recorder",
        "peekOfCode": "def load_macro(macro_name):\n    \"\"\"Load a saved macro\"\"\"\n    try:\n        macro_file = Path(\"macros\") / f\"{macro_name}.json\"\n        if not macro_file.exists():\n            return {\"error\": f\"Macro {macro_name} not found\"}\n        with open(macro_file, \"r\") as f:\n            macro_data = json.load(f)\n        return {\"success\": True, \"macro_data\": macro_data}\n    except Exception as e:",
        "detail": "modes.automation.macro_recorder",
        "documentation": {}
    },
    {
        "label": "replay_macro",
        "kind": 2,
        "importPath": "modes.automation.macro_recorder",
        "description": "modes.automation.macro_recorder",
        "peekOfCode": "def replay_macro(macro_name, speed_multiplier=1.0, repeat_count=1):\n    \"\"\"Replay a saved macro\"\"\"\n    try:\n        # Load macro\n        load_result = load_macro(macro_name)\n        if not load_result.get(\"success\"):\n            return load_result\n        macro_data = load_result[\"macro_data\"]\n        actions = macro_data[\"actions\"]\n        if not actions:",
        "detail": "modes.automation.macro_recorder",
        "documentation": {}
    },
    {
        "label": "list_macros",
        "kind": 2,
        "importPath": "modes.automation.macro_recorder",
        "description": "modes.automation.macro_recorder",
        "peekOfCode": "def list_macros():\n    \"\"\"List all saved macros\"\"\"\n    try:\n        macros_dir = Path(\"macros\")\n        if not macros_dir.exists():\n            return {\"success\": True, \"macros\": [], \"macro_count\": 0}\n        macros = []\n        for macro_file in macros_dir.glob(\"*.json\"):\n            try:\n                with open(macro_file, \"r\") as f:",
        "detail": "modes.automation.macro_recorder",
        "documentation": {}
    },
    {
        "label": "delete_macro",
        "kind": 2,
        "importPath": "modes.automation.macro_recorder",
        "description": "modes.automation.macro_recorder",
        "peekOfCode": "def delete_macro(macro_name):\n    \"\"\"Delete a saved macro\"\"\"\n    try:\n        macro_file = Path(\"macros\") / f\"{macro_name}.json\"\n        if not macro_file.exists():\n            return {\"error\": f\"Macro {macro_name} not found\"}\n        macro_file.unlink()\n        return {\n            \"success\": True,\n            \"macro_name\": macro_name,",
        "detail": "modes.automation.macro_recorder",
        "documentation": {}
    },
    {
        "label": "get_macro_recorder",
        "kind": 2,
        "importPath": "modes.automation.macro_recorder",
        "description": "modes.automation.macro_recorder",
        "peekOfCode": "def get_macro_recorder():\n    \"\"\"Get macro recorder capabilities\"\"\"\n    try:\n        return {\n            \"functions\": {\n                \"start_macro_recording\": \"start_macro_recording()\",\n                \"stop_macro_recording\": \"stop_macro_recording()\",\n                \"save_macro\": \"save_macro(macro_name, description='')\",\n                \"load_macro\": \"load_macro(macro_name)\",\n                \"replay_macro\": \"replay_macro(macro_name, speed_multiplier=1.0, repeat_count=1)\",",
        "detail": "modes.automation.macro_recorder",
        "documentation": {}
    },
    {
        "label": "_recorder",
        "kind": 5,
        "importPath": "modes.automation.macro_recorder",
        "description": "modes.automation.macro_recorder",
        "peekOfCode": "_recorder = MacroRecorder()\ndef start_macro_recording():\n    \"\"\"Start recording a macro\"\"\"\n    try:\n        return _recorder.start_recording()\n    except Exception as e:\n        return {\"error\": str(e)}\ndef stop_macro_recording():\n    \"\"\"Stop recording a macro\"\"\"\n    try:",
        "detail": "modes.automation.macro_recorder",
        "documentation": {}
    },
    {
        "label": "run_script",
        "kind": 2,
        "importPath": "modes.automation.script_runner",
        "description": "modes.automation.script_runner",
        "peekOfCode": "def run_script(script_path, args=None, working_dir=None, timeout=300, capture_output=True):\n    \"\"\"Run a script file\"\"\"\n    try:\n        script_file = Path(script_path)\n        if not script_file.exists():\n            return {\"error\": f\"Script file {script_path} does not exist\"}\n        if args is None:\n            args = []\n        # Determine how to run the script based on extension\n        extension = script_file.suffix.lower()",
        "detail": "modes.automation.script_runner",
        "documentation": {}
    },
    {
        "label": "run_command",
        "kind": 2,
        "importPath": "modes.automation.script_runner",
        "description": "modes.automation.script_runner",
        "peekOfCode": "def run_command(command, args=None, working_dir=None, timeout=60, shell=False):\n    \"\"\"Run a system command\"\"\"\n    try:\n        if args is None:\n            args = []\n        if shell:\n            # Run as shell command\n            full_command = f\"{command} {' '.join(args)}\"\n            cmd_list = full_command\n        else:",
        "detail": "modes.automation.script_runner",
        "documentation": {}
    },
    {
        "label": "create_and_run_script",
        "kind": 2,
        "importPath": "modes.automation.script_runner",
        "description": "modes.automation.script_runner",
        "peekOfCode": "def create_and_run_script(script_content, script_type=\"python\", args=None, cleanup=True):\n    \"\"\"Create a temporary script and run it\"\"\"\n    try:\n        # Determine file extension\n        extensions = {\n            \"python\": \".py\",\n            \"batch\": \".bat\",\n            \"powershell\": \".ps1\",\n            \"bash\": \".sh\"\n        }",
        "detail": "modes.automation.script_runner",
        "documentation": {}
    },
    {
        "label": "batch_run_scripts",
        "kind": 2,
        "importPath": "modes.automation.script_runner",
        "description": "modes.automation.script_runner",
        "peekOfCode": "def batch_run_scripts(script_list, parallel=False, stop_on_error=True):\n    \"\"\"Run multiple scripts in sequence or parallel\"\"\"\n    try:\n        results = []\n        if parallel:\n            # Run scripts in parallel\n            import concurrent.futures\n            with concurrent.futures.ThreadPoolExecutor() as executor:\n                futures = []\n                for script_info in script_list:",
        "detail": "modes.automation.script_runner",
        "documentation": {}
    },
    {
        "label": "get_script_runner",
        "kind": 2,
        "importPath": "modes.automation.script_runner",
        "description": "modes.automation.script_runner",
        "peekOfCode": "def get_script_runner():\n    \"\"\"Get script runner capabilities\"\"\"\n    try:\n        return {\n            \"functions\": {\n                \"run_script\": \"run_script(script_path, args=None, working_dir=None, timeout=300, capture_output=True)\",\n                \"run_command\": \"run_command(command, args=None, working_dir=None, timeout=60, shell=False)\",\n                \"create_and_run_script\": \"create_and_run_script(script_content, script_type='python', args=None, cleanup=True)\",\n                \"batch_run_scripts\": \"batch_run_scripts(script_list, parallel=False, stop_on_error=True)\"\n            },",
        "detail": "modes.automation.script_runner",
        "documentation": {}
    },
    {
        "label": "get_task_scheduler",
        "kind": 2,
        "importPath": "modes.automation.task_scheduler",
        "description": "modes.automation.task_scheduler",
        "peekOfCode": "def get_task_scheduler():\n    \"\"\"Get scheduled automation tasks\"\"\"\n    try:\n        if not TASKS_FILE.exists():\n            return {\"scheduled_tasks\": [], \"status\": \"no_tasks\"}\n        with open(TASKS_FILE, 'r') as f:\n            tasks = json.load(f)\n        active_tasks = []\n        for task in tasks:\n            # Check if task should be running",
        "detail": "modes.automation.task_scheduler",
        "documentation": {}
    },
    {
        "label": "TASKS_FILE",
        "kind": 5,
        "importPath": "modes.automation.task_scheduler",
        "description": "modes.automation.task_scheduler",
        "peekOfCode": "TASKS_FILE = Path(__file__).parent / \"scheduled_tasks.json\"\ndef get_task_scheduler():\n    \"\"\"Get scheduled automation tasks\"\"\"\n    try:\n        if not TASKS_FILE.exists():\n            return {\"scheduled_tasks\": [], \"status\": \"no_tasks\"}\n        with open(TASKS_FILE, 'r') as f:\n            tasks = json.load(f)\n        active_tasks = []\n        for task in tasks:",
        "detail": "modes.automation.task_scheduler",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.cloud.aggregator",
        "description": "modes.cloud.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for cloud monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.cloud.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.cloud.aggregator",
        "description": "modes.cloud.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.cloud.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.cloud.aggregator",
        "description": "modes.cloud.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.cloud.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.cloud.aggregator",
        "description": "modes.cloud.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for cloud monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.cloud.aggregator",
        "documentation": {}
    },
    {
        "label": "get_backup_sync",
        "kind": 2,
        "importPath": "modes.cloud.backup_sync",
        "description": "modes.cloud.backup_sync",
        "peekOfCode": "def get_backup_sync():\n    \"\"\"Get backup and sync status\"\"\"\n    try:\n        # Load sync configuration\n        if CONFIG_FILE.exists():\n            with open(CONFIG_FILE, 'r') as f:\n                config = json.load(f)\n        else:\n            config = {\n                \"enabled\": False,",
        "detail": "modes.cloud.backup_sync",
        "documentation": {}
    },
    {
        "label": "SYNC_LOG",
        "kind": 5,
        "importPath": "modes.cloud.backup_sync",
        "description": "modes.cloud.backup_sync",
        "peekOfCode": "SYNC_LOG = Path(__file__).parent / \"sync_log.json\"\nCONFIG_FILE = Path(__file__).parent / \"backup_config.json\"\ndef get_backup_sync():\n    \"\"\"Get backup and sync status\"\"\"\n    try:\n        # Load sync configuration\n        if CONFIG_FILE.exists():\n            with open(CONFIG_FILE, 'r') as f:\n                config = json.load(f)\n        else:",
        "detail": "modes.cloud.backup_sync",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.cloud.backup_sync",
        "description": "modes.cloud.backup_sync",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"backup_config.json\"\ndef get_backup_sync():\n    \"\"\"Get backup and sync status\"\"\"\n    try:\n        # Load sync configuration\n        if CONFIG_FILE.exists():\n            with open(CONFIG_FILE, 'r') as f:\n                config = json.load(f)\n        else:\n            config = {",
        "detail": "modes.cloud.backup_sync",
        "documentation": {}
    },
    {
        "label": "get_data_analytics",
        "kind": 2,
        "importPath": "modes.cloud.data_analytics",
        "description": "modes.cloud.data_analytics",
        "peekOfCode": "def get_data_analytics():\n    \"\"\"Get cloud analytics integration status\"\"\"\n    try:\n        # Load analytics history\n        if ANALYTICS_LOG.exists():\n            with open(ANALYTICS_LOG, 'r') as f:\n                analytics_data = json.load(f)\n        else:\n            analytics_data = {\"uploads\": [], \"dashboards\": []}\n        return {",
        "detail": "modes.cloud.data_analytics",
        "documentation": {}
    },
    {
        "label": "ANALYTICS_LOG",
        "kind": 5,
        "importPath": "modes.cloud.data_analytics",
        "description": "modes.cloud.data_analytics",
        "peekOfCode": "ANALYTICS_LOG = Path(__file__).parent / \"analytics_log.json\"\ndef get_data_analytics():\n    \"\"\"Get cloud analytics integration status\"\"\"\n    try:\n        # Load analytics history\n        if ANALYTICS_LOG.exists():\n            with open(ANALYTICS_LOG, 'r') as f:\n                analytics_data = json.load(f)\n        else:\n            analytics_data = {\"uploads\": [], \"dashboards\": []}",
        "detail": "modes.cloud.data_analytics",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.communication.aggregator",
        "description": "modes.communication.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for communication monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.communication.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.communication.aggregator",
        "description": "modes.communication.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.communication.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.communication.aggregator",
        "description": "modes.communication.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.communication.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.communication.aggregator",
        "description": "modes.communication.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for communication monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.communication.aggregator",
        "documentation": {}
    },
    {
        "label": "get_api_integration",
        "kind": 2,
        "importPath": "modes.communication.api_integration",
        "description": "modes.communication.api_integration",
        "peekOfCode": "def get_api_integration():\n    \"\"\"Get API integration status and capabilities\"\"\"\n    try:\n        # Load API configuration\n        if CONFIG_FILE.exists():\n            with open(CONFIG_FILE, 'r') as f:\n                config = json.load(f)\n        else:\n            config = {\n                \"apis\": {},",
        "detail": "modes.communication.api_integration",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.communication.api_integration",
        "description": "modes.communication.api_integration",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"api_config.json\"\nLOG_FILE = Path(__file__).parent / \"api_calls.json\"\ndef get_api_integration():\n    \"\"\"Get API integration status and capabilities\"\"\"\n    try:\n        # Load API configuration\n        if CONFIG_FILE.exists():\n            with open(CONFIG_FILE, 'r') as f:\n                config = json.load(f)\n        else:",
        "detail": "modes.communication.api_integration",
        "documentation": {}
    },
    {
        "label": "LOG_FILE",
        "kind": 5,
        "importPath": "modes.communication.api_integration",
        "description": "modes.communication.api_integration",
        "peekOfCode": "LOG_FILE = Path(__file__).parent / \"api_calls.json\"\ndef get_api_integration():\n    \"\"\"Get API integration status and capabilities\"\"\"\n    try:\n        # Load API configuration\n        if CONFIG_FILE.exists():\n            with open(CONFIG_FILE, 'r') as f:\n                config = json.load(f)\n        else:\n            config = {",
        "detail": "modes.communication.api_integration",
        "documentation": {}
    },
    {
        "label": "get_notifications",
        "kind": 2,
        "importPath": "modes.communication.notifications",
        "description": "modes.communication.notifications",
        "peekOfCode": "def get_notifications():\n    \"\"\"Get notification system status and recent notifications\"\"\"\n    try:\n        # Load recent notifications\n        if NOTIFICATION_LOG.exists():\n            with open(NOTIFICATION_LOG, 'r') as f:\n                data = json.load(f)\n        else:\n            data = {\"notifications\": []}\n        recent_notifications = data[\"notifications\"][-10:]  # Last 10",
        "detail": "modes.communication.notifications",
        "documentation": {}
    },
    {
        "label": "NOTIFICATION_LOG",
        "kind": 5,
        "importPath": "modes.communication.notifications",
        "description": "modes.communication.notifications",
        "peekOfCode": "NOTIFICATION_LOG = Path(__file__).parent / \"notifications.json\"\ndef get_notifications():\n    \"\"\"Get notification system status and recent notifications\"\"\"\n    try:\n        # Load recent notifications\n        if NOTIFICATION_LOG.exists():\n            with open(NOTIFICATION_LOG, 'r') as f:\n                data = json.load(f)\n        else:\n            data = {\"notifications\": []}",
        "detail": "modes.communication.notifications",
        "documentation": {}
    },
    {
        "label": "get_remote_control",
        "kind": 2,
        "importPath": "modes.communication.remote_control",
        "description": "modes.communication.remote_control",
        "peekOfCode": "def get_remote_control():\n    \"\"\"Get remote control capabilities and session status\"\"\"\n    try:\n        # Load remote sessions\n        if SESSION_FILE.exists():\n            with open(SESSION_FILE, 'r') as f:\n                sessions = json.load(f)\n        else:\n            sessions = {\"active_sessions\": [], \"session_history\": []}\n        # Load configuration",
        "detail": "modes.communication.remote_control",
        "documentation": {}
    },
    {
        "label": "SESSION_FILE",
        "kind": 5,
        "importPath": "modes.communication.remote_control",
        "description": "modes.communication.remote_control",
        "peekOfCode": "SESSION_FILE = Path(__file__).parent / \"remote_sessions.json\"\nCONFIG_FILE = Path(__file__).parent / \"remote_config.json\"\ndef get_remote_control():\n    \"\"\"Get remote control capabilities and session status\"\"\"\n    try:\n        # Load remote sessions\n        if SESSION_FILE.exists():\n            with open(SESSION_FILE, 'r') as f:\n                sessions = json.load(f)\n        else:",
        "detail": "modes.communication.remote_control",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.communication.remote_control",
        "description": "modes.communication.remote_control",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"remote_config.json\"\ndef get_remote_control():\n    \"\"\"Get remote control capabilities and session status\"\"\"\n    try:\n        # Load remote sessions\n        if SESSION_FILE.exists():\n            with open(SESSION_FILE, 'r') as f:\n                sessions = json.load(f)\n        else:\n            sessions = {\"active_sessions\": [], \"session_history\": []}",
        "detail": "modes.communication.remote_control",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.cpu.aggregator",
        "description": "modes.cpu.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for cpu monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]\n            excluded = {'Path', 'datetime', 'os', 'sys', 'json', 'time', 'subprocess', 'platform', 'shutil'}",
        "detail": "modes.cpu.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.cpu.aggregator",
        "description": "modes.cpu.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.cpu.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.cpu.aggregator",
        "description": "modes.cpu.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.cpu.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.cpu.aggregator",
        "description": "modes.cpu.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for cpu monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.cpu.aggregator",
        "documentation": {}
    },
    {
        "label": "get_cpu_speed",
        "kind": 2,
        "importPath": "modes.cpu.cpuspeed",
        "description": "modes.cpu.cpuspeed",
        "peekOfCode": "def get_cpu_speed():\n    \"\"\"\n    Get current CPU frequency in MHz.\n    Returns:\n        dict: {\"current_mhz\": float, \"min_mhz\": float, \"max_mhz\": float} or {\"error\": str}\n    \"\"\"\n    try:\n        freq = psutil.cpu_freq()\n        if freq:\n            return {",
        "detail": "modes.cpu.cpuspeed",
        "documentation": {}
    },
    {
        "label": "get_cpu_temp",
        "kind": 2,
        "importPath": "modes.cpu.cputemp",
        "description": "modes.cpu.cputemp",
        "peekOfCode": "def get_cpu_temp():\n    \"\"\"Get CPU temperature in Celsius\"\"\"\n    try:\n        # type: ignore[attr-defined]\n        temps = psutil.sensors_temperatures()\n        # Prioritize 'coretemp' (common on Linux) and average the readings.\n        if temps and 'coretemp' in temps and temps['coretemp']:\n            core_temps = temps['coretemp']\n            avg_temp = sum(t.current for t in core_temps) / len(core_temps)\n            high_thresh = core_temps[0].high",
        "detail": "modes.cpu.cputemp",
        "documentation": {}
    },
    {
        "label": "get_cpu_usage",
        "kind": 2,
        "importPath": "modes.cpu.cpu_usage",
        "description": "modes.cpu.cpu_usage",
        "peekOfCode": "def get_cpu_usage():\n    \"\"\"\n    Get CPU usage percentage and per-core usage.\n    Returns:\n        dict: {\"usage_percent\": float, \"per_core\": list, \"core_count\": int} or {\"error\": str}\n    \"\"\"\n    try:\n        per_core_usage = psutil.cpu_percent(interval=1, percpu=True)\n        return {\n            \"usage_percent\": sum(per_core_usage) / len(per_core_usage) if per_core_usage else 0,",
        "detail": "modes.cpu.cpu_usage",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.development.aggregator",
        "description": "modes.development.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for development monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.development.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.development.aggregator",
        "description": "modes.development.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.development.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.development.aggregator",
        "description": "modes.development.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.development.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.development.aggregator",
        "description": "modes.development.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for development monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.development.aggregator",
        "documentation": {}
    },
    {
        "label": "get_build_monitoring",
        "kind": 2,
        "importPath": "modes.development.build_monitoring",
        "description": "modes.development.build_monitoring",
        "peekOfCode": "def get_build_monitoring():\n    \"\"\"Monitor development builds and processes\"\"\"\n    try:\n        # Load build history\n        if BUILD_LOG.exists():\n            with open(BUILD_LOG, 'r') as f:\n                build_data = json.load(f)\n        else:\n            build_data = {\"builds\": [], \"processes\": []}\n        # Check for common build processes",
        "detail": "modes.development.build_monitoring",
        "documentation": {}
    },
    {
        "label": "BUILD_LOG",
        "kind": 5,
        "importPath": "modes.development.build_monitoring",
        "description": "modes.development.build_monitoring",
        "peekOfCode": "BUILD_LOG = Path(__file__).parent / \"build_log.json\"\ndef get_build_monitoring():\n    \"\"\"Monitor development builds and processes\"\"\"\n    try:\n        # Load build history\n        if BUILD_LOG.exists():\n            with open(BUILD_LOG, 'r') as f:\n                build_data = json.load(f)\n        else:\n            build_data = {\"builds\": [], \"processes\": []}",
        "detail": "modes.development.build_monitoring",
        "documentation": {}
    },
    {
        "label": "get_code_analysis",
        "kind": 2,
        "importPath": "modes.development.code_analysis",
        "description": "modes.development.code_analysis",
        "peekOfCode": "def get_code_analysis():\n    \"\"\"Analyze code projects and development patterns\"\"\"\n    try:\n        # Scan for common development directories\n        common_dev_paths = [\n            Path.home() / \"Documents\",\n            Path.home() / \"Desktop\", \n            Path(\"C:/dev\"),\n            Path(\"C:/projects\"),\n            Path(\"C:/code\")",
        "detail": "modes.development.code_analysis",
        "documentation": {}
    },
    {
        "label": "ANALYSIS_LOG",
        "kind": 5,
        "importPath": "modes.development.code_analysis",
        "description": "modes.development.code_analysis",
        "peekOfCode": "ANALYSIS_LOG = Path(__file__).parent / \"code_analysis.json\"\ndef get_code_analysis():\n    \"\"\"Analyze code projects and development patterns\"\"\"\n    try:\n        # Scan for common development directories\n        common_dev_paths = [\n            Path.home() / \"Documents\",\n            Path.home() / \"Desktop\", \n            Path(\"C:/dev\"),\n            Path(\"C:/projects\"),",
        "detail": "modes.development.code_analysis",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.environment.aggregator",
        "description": "modes.environment.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for environment monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.environment.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.environment.aggregator",
        "description": "modes.environment.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.environment.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.environment.aggregator",
        "description": "modes.environment.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.environment.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.environment.aggregator",
        "description": "modes.environment.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for environment monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.environment.aggregator",
        "documentation": {}
    },
    {
        "label": "get_audio_devices",
        "kind": 2,
        "importPath": "modes.environment.audio_devices",
        "description": "modes.environment.audio_devices",
        "peekOfCode": "def get_audio_devices():\n    \"\"\"Get audio device information\"\"\"\n    try:\n        if platform.system() == \"Windows\":\n            # Get audio devices using PowerShell\n            ps_script = \"\"\"\n            Get-WmiObject -Class Win32_SoundDevice | Select-Object Name, Status | ConvertTo-Json\n            \"\"\"\n            result = subprocess.run(\n                [\"powershell\", \"-Command\", ps_script],",
        "detail": "modes.environment.audio_devices",
        "documentation": {}
    },
    {
        "label": "get_screen_info",
        "kind": 2,
        "importPath": "modes.environment.screen_info",
        "description": "modes.environment.screen_info",
        "peekOfCode": "def get_screen_info():\n    \"\"\"Get screen/display information\"\"\"\n    try:\n        if platform.system() == \"Windows\":\n            try:\n                import win32api\n                monitors = []\n                for i, monitor in enumerate(win32api.EnumDisplayMonitors()):\n                    monitor_info = win32api.GetMonitorInfo(monitor[0])\n                    monitors.append({",
        "detail": "modes.environment.screen_info",
        "documentation": {}
    },
    {
        "label": "get_usb_devices",
        "kind": 2,
        "importPath": "modes.environment.usb_devices",
        "description": "modes.environment.usb_devices",
        "peekOfCode": "def get_usb_devices():\n    \"\"\"Get connected USB devices\"\"\"\n    try:\n        if platform.system() == \"Windows\":\n            # Get USB devices using PowerShell\n            ps_script = \"\"\"\n            Get-WmiObject -Class Win32_USBControllerDevice | ForEach-Object {\n                [wmi]($_.Dependent)\n            } | Where-Object {$_.Description -ne $null} | Select-Object Description, DeviceID | ConvertTo-Json\n            \"\"\"",
        "detail": "modes.environment.usb_devices",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.files.aggregator",
        "description": "modes.files.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for files monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.files.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.files.aggregator",
        "description": "modes.files.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.files.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.files.aggregator",
        "description": "modes.files.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.files.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.files.aggregator",
        "description": "modes.files.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for files monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.files.aggregator",
        "documentation": {}
    },
    {
        "label": "create_directory",
        "kind": 2,
        "importPath": "modes.files.directory_ops",
        "description": "modes.files.directory_ops",
        "peekOfCode": "def create_directory(directory_path, parents=True, exist_ok=True):\n    \"\"\"Create a directory\"\"\"\n    try:\n        dir_path = Path(directory_path)\n        dir_path.mkdir(parents=parents, exist_ok=exist_ok)\n        return {\n            \"success\": True,\n            \"path\": str(dir_path.absolute()),\n            \"created\": datetime.now().isoformat(),\n            \"parents_created\": parents,",
        "detail": "modes.files.directory_ops",
        "documentation": {}
    },
    {
        "label": "organize_files_by_extension",
        "kind": 2,
        "importPath": "modes.files.directory_ops",
        "description": "modes.files.directory_ops",
        "peekOfCode": "def organize_files_by_extension(source_dir, destination_dir=None, create_subdirs=True):\n    \"\"\"Organize files into subdirectories by extension\"\"\"\n    try:\n        src_path = Path(source_dir)\n        if not src_path.exists():\n            return {\"error\": f\"Source directory {source_dir} does not exist\"}\n        dst_path = Path(destination_dir) if destination_dir else src_path\n        dst_path.mkdir(parents=True, exist_ok=True)\n        organized_files = {}\n        moved_count = 0",
        "detail": "modes.files.directory_ops",
        "documentation": {}
    },
    {
        "label": "organize_files_by_date",
        "kind": 2,
        "importPath": "modes.files.directory_ops",
        "description": "modes.files.directory_ops",
        "peekOfCode": "def organize_files_by_date(source_dir, destination_dir=None, date_format=\"YYYY/MM\"):\n    \"\"\"Organize files into subdirectories by creation/modification date\"\"\"\n    try:\n        src_path = Path(source_dir)\n        if not src_path.exists():\n            return {\"error\": f\"Source directory {source_dir} does not exist\"}\n        dst_path = Path(destination_dir) if destination_dir else src_path\n        dst_path.mkdir(parents=True, exist_ok=True)\n        organized_files = {}\n        moved_count = 0",
        "detail": "modes.files.directory_ops",
        "documentation": {}
    },
    {
        "label": "get_directory_stats",
        "kind": 2,
        "importPath": "modes.files.directory_ops",
        "description": "modes.files.directory_ops",
        "peekOfCode": "def get_directory_stats(directory):\n    \"\"\"Get comprehensive directory statistics\"\"\"\n    try:\n        dir_path = Path(directory)\n        if not dir_path.exists():\n            return {\"error\": f\"Directory {directory} does not exist\"}\n        stats = {\n            \"path\": str(dir_path.absolute()),\n            \"total_files\": 0,\n            \"total_directories\": 0,",
        "detail": "modes.files.directory_ops",
        "documentation": {}
    },
    {
        "label": "get_directory_ops",
        "kind": 2,
        "importPath": "modes.files.directory_ops",
        "description": "modes.files.directory_ops",
        "peekOfCode": "def get_directory_ops():\n    \"\"\"Get directory operations capabilities\"\"\"\n    try:\n        return {\n            \"functions\": {\n                \"create_directory\": \"create_directory(directory_path, parents=True, exist_ok=True)\",\n                \"organize_files_by_extension\": \"organize_files_by_extension(source_dir, destination_dir=None, create_subdirs=True)\",\n                \"organize_files_by_date\": \"organize_files_by_date(source_dir, destination_dir=None, date_format='YYYY/MM')\",\n                \"get_directory_stats\": \"get_directory_stats(directory)\"\n            },",
        "detail": "modes.files.directory_ops",
        "documentation": {}
    },
    {
        "label": "copy_file",
        "kind": 2,
        "importPath": "modes.files.file_copy",
        "description": "modes.files.file_copy",
        "peekOfCode": "def copy_file(source, destination, preserve_metadata=True, verify_copy=False):\n    \"\"\"Copy a file or directory\"\"\"\n    try:\n        src_path = Path(source)\n        dst_path = Path(destination)\n        if not src_path.exists():\n            return {\"error\": f\"Source {source} does not exist\"}\n        # Create destination directory if needed\n        if src_path.is_file():\n            dst_path.parent.mkdir(parents=True, exist_ok=True)",
        "detail": "modes.files.file_copy",
        "documentation": {}
    },
    {
        "label": "batch_copy",
        "kind": 2,
        "importPath": "modes.files.file_copy",
        "description": "modes.files.file_copy",
        "peekOfCode": "def batch_copy(source_dir, destination_dir, file_pattern=\"*\", preserve_structure=True):\n    \"\"\"Batch copy files matching pattern\"\"\"\n    try:\n        src_path = Path(source_dir)\n        dst_path = Path(destination_dir)\n        if not src_path.exists():\n            return {\"error\": f\"Source directory {source_dir} does not exist\"}\n        dst_path.mkdir(parents=True, exist_ok=True)\n        copied_files = []\n        errors = []",
        "detail": "modes.files.file_copy",
        "documentation": {}
    },
    {
        "label": "get_file_copy",
        "kind": 2,
        "importPath": "modes.files.file_copy",
        "description": "modes.files.file_copy",
        "peekOfCode": "def get_file_copy():\n    \"\"\"Get file copy capabilities\"\"\"\n    try:\n        return {\n            \"functions\": {\n                \"copy_file\": \"copy_file(source, destination, preserve_metadata=True, verify_copy=False)\",\n                \"batch_copy\": \"batch_copy(source_dir, destination_dir, file_pattern='*', preserve_structure=True)\"\n            },\n            \"features\": [\n                \"Metadata preservation\",",
        "detail": "modes.files.file_copy",
        "documentation": {}
    },
    {
        "label": "create_file",
        "kind": 2,
        "importPath": "modes.files.file_create",
        "description": "modes.files.file_create",
        "peekOfCode": "def create_file(filepath, content=\"\", template=None, overwrite=False):\n    \"\"\"Create a file with specified content or template\"\"\"\n    try:\n        file_path = Path(filepath)\n        # Check if file exists and overwrite is False\n        if file_path.exists() and not overwrite:\n            return {\"error\": f\"File {filepath} already exists. Use overwrite=True to replace.\"}\n        # Create directory if it doesn't exist\n        file_path.parent.mkdir(parents=True, exist_ok=True)\n        # Apply template if specified",
        "detail": "modes.files.file_create",
        "documentation": {}
    },
    {
        "label": "get_file_create",
        "kind": 2,
        "importPath": "modes.files.file_create",
        "description": "modes.files.file_create",
        "peekOfCode": "def get_file_create():\n    \"\"\"Get file creation statistics and available templates\"\"\"\n    try:\n        templates = [\"python\", \"html\", \"javascript\", \"css\", \"markdown\", \"json\", \"txt\"]\n        return {\n            \"available_templates\": templates,\n            \"function\": \"create_file(filepath, content='', template=None, overwrite=False)\",\n            \"examples\": {\n                \"basic\": \"create_file('test.txt', 'Hello World')\",\n                \"template\": \"create_file('script.py', template='python')\",",
        "detail": "modes.files.file_create",
        "documentation": {}
    },
    {
        "label": "delete_file",
        "kind": 2,
        "importPath": "modes.files.file_delete",
        "description": "modes.files.file_delete",
        "peekOfCode": "def delete_file(filepath, use_recycle_bin=True, force=False):\n    \"\"\"Delete a file or directory\"\"\"\n    try:\n        file_path = Path(filepath)\n        if not file_path.exists():\n            return {\"error\": f\"Path {filepath} does not exist\"}\n        file_info = {\n            \"path\": str(file_path.absolute()),\n            \"is_directory\": file_path.is_dir(),\n            \"size_bytes\": file_path.stat().st_size if file_path.is_file() else 0,",
        "detail": "modes.files.file_delete",
        "documentation": {}
    },
    {
        "label": "cleanup_temp_files",
        "kind": 2,
        "importPath": "modes.files.file_delete",
        "description": "modes.files.file_delete",
        "peekOfCode": "def cleanup_temp_files(directory, older_than_days=7, file_patterns=None):\n    \"\"\"Clean up temporary files older than specified days\"\"\"\n    try:\n        dir_path = Path(directory)\n        if not dir_path.exists():\n            return {\"error\": f\"Directory {directory} does not exist\"}\n        if file_patterns is None:\n            file_patterns = [\"*.tmp\", \"*.temp\", \"*.log\", \"*~\", \"*.bak\"]\n        import time\n        cutoff_time = time.time() - (older_than_days * 24 * 60 * 60)",
        "detail": "modes.files.file_delete",
        "documentation": {}
    },
    {
        "label": "get_file_delete",
        "kind": 2,
        "importPath": "modes.files.file_delete",
        "description": "modes.files.file_delete",
        "peekOfCode": "def get_file_delete():\n    \"\"\"Get file deletion capabilities\"\"\"\n    try:\n        return {\n            \"functions\": {\n                \"delete_file\": \"delete_file(filepath, use_recycle_bin=True, force=False)\",\n                \"cleanup_temp_files\": \"cleanup_temp_files(directory, older_than_days=7, file_patterns=None)\"\n            },\n            \"safety_features\": [\n                \"Recycle bin support (requires send2trash: pip install send2trash)\",",
        "detail": "modes.files.file_delete",
        "documentation": {}
    },
    {
        "label": "rename_file",
        "kind": 2,
        "importPath": "modes.files.file_rename",
        "description": "modes.files.file_rename",
        "peekOfCode": "def rename_file(old_path, new_path, create_backup=False):\n    \"\"\"Rename a file or directory\"\"\"\n    try:\n        old_file = Path(old_path)\n        new_file = Path(new_path)\n        if not old_file.exists():\n            return {\"error\": f\"Source path {old_path} does not exist\"}\n        if new_file.exists():\n            return {\"error\": f\"Destination path {new_path} already exists\"}\n        # Create backup if requested",
        "detail": "modes.files.file_rename",
        "documentation": {}
    },
    {
        "label": "batch_rename",
        "kind": 2,
        "importPath": "modes.files.file_rename",
        "description": "modes.files.file_rename",
        "peekOfCode": "def batch_rename(directory, pattern, replacement, file_extension=None):\n    \"\"\"Batch rename files in a directory\"\"\"\n    try:\n        dir_path = Path(directory)\n        if not dir_path.exists() or not dir_path.is_dir():\n            return {\"error\": f\"Directory {directory} does not exist\"}\n        renamed_files = []\n        errors = []\n        for file_path in dir_path.iterdir():\n            if file_path.is_file():",
        "detail": "modes.files.file_rename",
        "documentation": {}
    },
    {
        "label": "get_file_rename",
        "kind": 2,
        "importPath": "modes.files.file_rename",
        "description": "modes.files.file_rename",
        "peekOfCode": "def get_file_rename():\n    \"\"\"Get file rename capabilities and statistics\"\"\"\n    try:\n        return {\n            \"functions\": {\n                \"rename_file\": \"rename_file(old_path, new_path, create_backup=False)\",\n                \"batch_rename\": \"batch_rename(directory, pattern, replacement, file_extension=None)\"\n            },\n            \"examples\": {\n                \"single_rename\": \"rename_file('old_name.txt', 'new_name.txt')\",",
        "detail": "modes.files.file_rename",
        "documentation": {}
    },
    {
        "label": "search_files",
        "kind": 2,
        "importPath": "modes.files.file_search",
        "description": "modes.files.file_search",
        "peekOfCode": "def search_files(directory, name_pattern=None, content_pattern=None, file_extension=None, \n                modified_within_days=None, size_min_mb=None, size_max_mb=None):\n    \"\"\"Search for files based on various criteria\"\"\"\n    try:\n        dir_path = Path(directory)\n        if not dir_path.exists():\n            return {\"error\": f\"Directory {directory} does not exist\"}\n        found_files = []\n        # Calculate time threshold if specified\n        time_threshold = None",
        "detail": "modes.files.file_search",
        "documentation": {}
    },
    {
        "label": "find_duplicates",
        "kind": 2,
        "importPath": "modes.files.file_search",
        "description": "modes.files.file_search",
        "peekOfCode": "def find_duplicates(directory, compare_by=\"name\"):\n    \"\"\"Find duplicate files in directory\"\"\"\n    try:\n        dir_path = Path(directory)\n        if not dir_path.exists():\n            return {\"error\": f\"Directory {directory} does not exist\"}\n        files_dict = {}\n        duplicates = []\n        for file_path in dir_path.rglob(\"*\"):\n            if not file_path.is_file():",
        "detail": "modes.files.file_search",
        "documentation": {}
    },
    {
        "label": "get_file_search",
        "kind": 2,
        "importPath": "modes.files.file_search",
        "description": "modes.files.file_search",
        "peekOfCode": "def get_file_search():\n    \"\"\"Get file search capabilities\"\"\"\n    try:\n        return {\n            \"functions\": {\n                \"search_files\": \"search_files(directory, name_pattern=None, content_pattern=None, file_extension=None, modified_within_days=None, size_min_mb=None, size_max_mb=None)\",\n                \"find_duplicates\": \"find_duplicates(directory, compare_by='name')\"\n            },\n            \"search_criteria\": [\n                \"File name pattern (regex)\",",
        "detail": "modes.files.file_search",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.gaming.aggregator",
        "description": "modes.gaming.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for gaming monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.gaming.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.gaming.aggregator",
        "description": "modes.gaming.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.gaming.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.gaming.aggregator",
        "description": "modes.gaming.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.gaming.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.gaming.aggregator",
        "description": "modes.gaming.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for gaming monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.gaming.aggregator",
        "documentation": {}
    },
    {
        "label": "get_game_automation",
        "kind": 2,
        "importPath": "modes.gaming.game_automation",
        "description": "modes.gaming.game_automation",
        "peekOfCode": "def get_game_automation():\n    \"\"\"Get game automation capabilities and active automations\"\"\"\n    try:\n        if not PROFILES_DIR.exists():\n            PROFILES_DIR.mkdir(exist_ok=True)\n        # Load automation profiles\n        profiles = []\n        for profile_file in PROFILES_DIR.glob(\"*.json\"):\n            try:\n                with open(profile_file, 'r') as f:",
        "detail": "modes.gaming.game_automation",
        "documentation": {}
    },
    {
        "label": "AUTOMATION_LOG",
        "kind": 5,
        "importPath": "modes.gaming.game_automation",
        "description": "modes.gaming.game_automation",
        "peekOfCode": "AUTOMATION_LOG = Path(__file__).parent / \"game_automation.json\"\nPROFILES_DIR = Path(__file__).parent / \"game_profiles\"\ndef get_game_automation():\n    \"\"\"Get game automation capabilities and active automations\"\"\"\n    try:\n        if not PROFILES_DIR.exists():\n            PROFILES_DIR.mkdir(exist_ok=True)\n        # Load automation profiles\n        profiles = []\n        for profile_file in PROFILES_DIR.glob(\"*.json\"):",
        "detail": "modes.gaming.game_automation",
        "documentation": {}
    },
    {
        "label": "PROFILES_DIR",
        "kind": 5,
        "importPath": "modes.gaming.game_automation",
        "description": "modes.gaming.game_automation",
        "peekOfCode": "PROFILES_DIR = Path(__file__).parent / \"game_profiles\"\ndef get_game_automation():\n    \"\"\"Get game automation capabilities and active automations\"\"\"\n    try:\n        if not PROFILES_DIR.exists():\n            PROFILES_DIR.mkdir(exist_ok=True)\n        # Load automation profiles\n        profiles = []\n        for profile_file in PROFILES_DIR.glob(\"*.json\"):\n            try:",
        "detail": "modes.gaming.game_automation",
        "documentation": {}
    },
    {
        "label": "get_game_detection",
        "kind": 2,
        "importPath": "modes.gaming.game_detection",
        "description": "modes.gaming.game_detection",
        "peekOfCode": "def get_game_detection():\n    \"\"\"Detect running games and provide game-specific information\"\"\"\n    try:\n        # Load game database\n        if GAME_DB.exists():\n            with open(GAME_DB, 'r') as f:\n                game_db = json.load(f)\n        else:\n            # Create basic game database\n            game_db = {",
        "detail": "modes.gaming.game_detection",
        "documentation": {}
    },
    {
        "label": "GAME_DB",
        "kind": 5,
        "importPath": "modes.gaming.game_detection",
        "description": "modes.gaming.game_detection",
        "peekOfCode": "GAME_DB = Path(__file__).parent / \"game_database.json\"\nDETECTION_LOG = Path(__file__).parent / \"game_detections.json\"\ndef get_game_detection():\n    \"\"\"Detect running games and provide game-specific information\"\"\"\n    try:\n        # Load game database\n        if GAME_DB.exists():\n            with open(GAME_DB, 'r') as f:\n                game_db = json.load(f)\n        else:",
        "detail": "modes.gaming.game_detection",
        "documentation": {}
    },
    {
        "label": "DETECTION_LOG",
        "kind": 5,
        "importPath": "modes.gaming.game_detection",
        "description": "modes.gaming.game_detection",
        "peekOfCode": "DETECTION_LOG = Path(__file__).parent / \"game_detections.json\"\ndef get_game_detection():\n    \"\"\"Detect running games and provide game-specific information\"\"\"\n    try:\n        # Load game database\n        if GAME_DB.exists():\n            with open(GAME_DB, 'r') as f:\n                game_db = json.load(f)\n        else:\n            # Create basic game database",
        "detail": "modes.gaming.game_detection",
        "documentation": {}
    },
    {
        "label": "get_performance_optimization",
        "kind": 2,
        "importPath": "modes.gaming.performance_optimization",
        "description": "modes.gaming.performance_optimization",
        "peekOfCode": "def get_performance_optimization():\n    \"\"\"Get game performance optimization status and recommendations\"\"\"\n    try:\n        # Get current system state\n        cpu_percent = psutil.cpu_percent(interval=1)\n        memory = psutil.virtual_memory()\n        # Generate optimization recommendations\n        recommendations = []\n        if cpu_percent > 80:\n            recommendations.append({",
        "detail": "modes.gaming.performance_optimization",
        "documentation": {}
    },
    {
        "label": "OPTIMIZATION_LOG",
        "kind": 5,
        "importPath": "modes.gaming.performance_optimization",
        "description": "modes.gaming.performance_optimization",
        "peekOfCode": "OPTIMIZATION_LOG = Path(__file__).parent / \"optimizations.json\"\ndef get_performance_optimization():\n    \"\"\"Get game performance optimization status and recommendations\"\"\"\n    try:\n        # Get current system state\n        cpu_percent = psutil.cpu_percent(interval=1)\n        memory = psutil.virtual_memory()\n        # Generate optimization recommendations\n        recommendations = []\n        if cpu_percent > 80:",
        "detail": "modes.gaming.performance_optimization",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.gpu.aggregator",
        "description": "modes.gpu.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for gpu monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.gpu.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.gpu.aggregator",
        "description": "modes.gpu.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.gpu.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.gpu.aggregator",
        "description": "modes.gpu.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.gpu.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.gpu.aggregator",
        "description": "modes.gpu.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for gpu monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.gpu.aggregator",
        "documentation": {}
    },
    {
        "label": "get_gpu_memory",
        "kind": 2,
        "importPath": "modes.gpu.gpuspeed",
        "description": "modes.gpu.gpuspeed",
        "peekOfCode": "def get_gpu_memory():\n    \"\"\"Get GPU memory details in MiB\"\"\"\n    if not GPU_AVAILABLE:\n        return {\"error\": \"GPUtil not installed. Run: pip install GPUtil\"}\n    try:\n        gpus = GPUtil.getGPUs()\n        if not gpus:\n            return {\"error\": \"No GPUs detected\"}\n        gpu_memory_data = []\n        for gpu in gpus:",
        "detail": "modes.gpu.gpuspeed",
        "documentation": {}
    },
    {
        "label": "get_gpu_temp",
        "kind": 2,
        "importPath": "modes.gpu.gputemp",
        "description": "modes.gpu.gputemp",
        "peekOfCode": "def get_gpu_temp():\n    \"\"\"Get GPU temperature\"\"\"\n    if not GPU_AVAILABLE:\n        return {\"error\": \"GPUtil not installed. Run: pip install GPUtil\"}\n    try:\n        gpus = GPUtil.getGPUs()\n        if not gpus:\n            return {\"error\": \"No GPUs detected\"}\n        gpu_temps = []\n        for gpu in gpus:",
        "detail": "modes.gpu.gputemp",
        "documentation": {}
    },
    {
        "label": "get_gpu_usage",
        "kind": 2,
        "importPath": "modes.gpu.gpu_usage",
        "description": "modes.gpu.gpu_usage",
        "peekOfCode": "def get_gpu_usage():\n    \"\"\"Get GPU usage percentage\"\"\"\n    if not GPU_AVAILABLE:\n        return {\"error\": \"GPUtil not installed. Run: pip install GPUtil\"}\n    try:\n        gpus = GPUtil.getGPUs()\n        if not gpus:\n            return {\"error\": \"No GPUs detected\"}\n        gpu_usage = []\n        for gpu in gpus:",
        "detail": "modes.gpu.gpu_usage",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.health.aggregator",
        "description": "modes.health.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for health monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.health.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.health.aggregator",
        "description": "modes.health.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.health.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.health.aggregator",
        "description": "modes.health.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.health.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.health.aggregator",
        "description": "modes.health.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for health monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.health.aggregator",
        "documentation": {}
    },
    {
        "label": "get_maintenance_scheduler",
        "kind": 2,
        "importPath": "modes.health.maintenance_scheduler",
        "description": "modes.health.maintenance_scheduler",
        "peekOfCode": "def get_maintenance_scheduler():\n    \"\"\"Get maintenance scheduling status and upcoming tasks\"\"\"\n    try:\n        # Load maintenance schedule\n        if SCHEDULE_FILE.exists():\n            with open(SCHEDULE_FILE, 'r') as f:\n                schedule = json.load(f)\n        else:\n            # Create default maintenance schedule\n            schedule = {",
        "detail": "modes.health.maintenance_scheduler",
        "documentation": {}
    },
    {
        "label": "MAINTENANCE_LOG",
        "kind": 5,
        "importPath": "modes.health.maintenance_scheduler",
        "description": "modes.health.maintenance_scheduler",
        "peekOfCode": "MAINTENANCE_LOG = Path(__file__).parent / \"maintenance_log.json\"\nSCHEDULE_FILE = Path(__file__).parent / \"maintenance_schedule.json\"\ndef get_maintenance_scheduler():\n    \"\"\"Get maintenance scheduling status and upcoming tasks\"\"\"\n    try:\n        # Load maintenance schedule\n        if SCHEDULE_FILE.exists():\n            with open(SCHEDULE_FILE, 'r') as f:\n                schedule = json.load(f)\n        else:",
        "detail": "modes.health.maintenance_scheduler",
        "documentation": {}
    },
    {
        "label": "SCHEDULE_FILE",
        "kind": 5,
        "importPath": "modes.health.maintenance_scheduler",
        "description": "modes.health.maintenance_scheduler",
        "peekOfCode": "SCHEDULE_FILE = Path(__file__).parent / \"maintenance_schedule.json\"\ndef get_maintenance_scheduler():\n    \"\"\"Get maintenance scheduling status and upcoming tasks\"\"\"\n    try:\n        # Load maintenance schedule\n        if SCHEDULE_FILE.exists():\n            with open(SCHEDULE_FILE, 'r') as f:\n                schedule = json.load(f)\n        else:\n            # Create default maintenance schedule",
        "detail": "modes.health.maintenance_scheduler",
        "documentation": {}
    },
    {
        "label": "get_system_diagnostics",
        "kind": 2,
        "importPath": "modes.health.system_diagnostics",
        "description": "modes.health.system_diagnostics",
        "peekOfCode": "def get_system_diagnostics():\n    \"\"\"Perform comprehensive system health diagnostics\"\"\"\n    try:\n        diagnostics = {\n            \"timestamp\": time.time(),\n            \"overall_health\": \"unknown\",\n            \"issues\": [],\n            \"recommendations\": []\n        }\n        # CPU Health Check",
        "detail": "modes.health.system_diagnostics",
        "documentation": {}
    },
    {
        "label": "DIAGNOSTIC_LOG",
        "kind": 5,
        "importPath": "modes.health.system_diagnostics",
        "description": "modes.health.system_diagnostics",
        "peekOfCode": "DIAGNOSTIC_LOG = Path(__file__).parent / \"diagnostics.json\"\ndef get_system_diagnostics():\n    \"\"\"Perform comprehensive system health diagnostics\"\"\"\n    try:\n        diagnostics = {\n            \"timestamp\": time.time(),\n            \"overall_health\": \"unknown\",\n            \"issues\": [],\n            \"recommendations\": []\n        }",
        "detail": "modes.health.system_diagnostics",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.input.aggregator",
        "description": "modes.input.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for input monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.input.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.input.aggregator",
        "description": "modes.input.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.input.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.input.aggregator",
        "description": "modes.input.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.input.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.input.aggregator",
        "description": "modes.input.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for input monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.input.aggregator",
        "documentation": {}
    },
    {
        "label": "get_clipboard_stats",
        "kind": 2,
        "importPath": "modes.input.clipboard_stats",
        "description": "modes.input.clipboard_stats",
        "peekOfCode": "def get_clipboard_stats():\n    \"\"\"Get clipboard usage statistics\"\"\"\n    try:\n        if STATS_FILE.exists():\n            with open(STATS_FILE, 'r') as f:\n                stats = json.load(f)\n        else:\n            stats = {\n                \"copy_events\": 0,\n                \"paste_events\": 0,",
        "detail": "modes.input.clipboard_stats",
        "documentation": {}
    },
    {
        "label": "STATS_FILE",
        "kind": 5,
        "importPath": "modes.input.clipboard_stats",
        "description": "modes.input.clipboard_stats",
        "peekOfCode": "STATS_FILE = Path(__file__).parent / \"clipboard_stats.json\"\ndef get_clipboard_stats():\n    \"\"\"Get clipboard usage statistics\"\"\"\n    try:\n        if STATS_FILE.exists():\n            with open(STATS_FILE, 'r') as f:\n                stats = json.load(f)\n        else:\n            stats = {\n                \"copy_events\": 0,",
        "detail": "modes.input.clipboard_stats",
        "documentation": {}
    },
    {
        "label": "get_keyboard_stats",
        "kind": 2,
        "importPath": "modes.input.keyboard_stats",
        "description": "modes.input.keyboard_stats",
        "peekOfCode": "def get_keyboard_stats():\n    \"\"\"Get keyboard usage statistics\"\"\"\n    try:\n        if STATS_FILE.exists():\n            with open(STATS_FILE, 'r') as f:\n                stats = json.load(f)\n        else:\n            stats = {\n                \"total_keystrokes\": 0,\n                \"session_start\": time.time(),",
        "detail": "modes.input.keyboard_stats",
        "documentation": {}
    },
    {
        "label": "STATS_FILE",
        "kind": 5,
        "importPath": "modes.input.keyboard_stats",
        "description": "modes.input.keyboard_stats",
        "peekOfCode": "STATS_FILE = Path(__file__).parent / \"keyboard_stats.json\"\ndef get_keyboard_stats():\n    \"\"\"Get keyboard usage statistics\"\"\"\n    try:\n        if STATS_FILE.exists():\n            with open(STATS_FILE, 'r') as f:\n                stats = json.load(f)\n        else:\n            stats = {\n                \"total_keystrokes\": 0,",
        "detail": "modes.input.keyboard_stats",
        "documentation": {}
    },
    {
        "label": "get_mouse_stats",
        "kind": 2,
        "importPath": "modes.input.mouse_stats",
        "description": "modes.input.mouse_stats",
        "peekOfCode": "def get_mouse_stats():\n    \"\"\"Get mouse usage statistics\"\"\"\n    try:\n        if STATS_FILE.exists():\n            with open(STATS_FILE, 'r') as f:\n                stats = json.load(f)\n        else:\n            stats = {\n                \"total_clicks\": 0,\n                \"left_clicks\": 0,",
        "detail": "modes.input.mouse_stats",
        "documentation": {}
    },
    {
        "label": "STATS_FILE",
        "kind": 5,
        "importPath": "modes.input.mouse_stats",
        "description": "modes.input.mouse_stats",
        "peekOfCode": "STATS_FILE = Path(__file__).parent / \"mouse_stats.json\"\ndef get_mouse_stats():\n    \"\"\"Get mouse usage statistics\"\"\"\n    try:\n        if STATS_FILE.exists():\n            with open(STATS_FILE, 'r') as f:\n                stats = json.load(f)\n        else:\n            stats = {\n                \"total_clicks\": 0,",
        "detail": "modes.input.mouse_stats",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.memory.aggregator",
        "description": "modes.memory.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for memory monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.memory.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.memory.aggregator",
        "description": "modes.memory.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.memory.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.memory.aggregator",
        "description": "modes.memory.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.memory.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.memory.aggregator",
        "description": "modes.memory.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for memory monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.memory.aggregator",
        "documentation": {}
    },
    {
        "label": "get_mem_free",
        "kind": 2,
        "importPath": "modes.memory.memfree",
        "description": "modes.memory.memfree",
        "peekOfCode": "def get_mem_free():\n    \"\"\"Get available/free memory\"\"\"\n    try:\n        mem = psutil.virtual_memory()\n        return {\n            \"available_bytes\": mem.available,\n            \"available_gb\": round(mem.available / (1024**3), 2),\n            \"free_bytes\": mem.free,\n            \"free_gb\": round(mem.free / (1024**3), 2)\n        }",
        "detail": "modes.memory.memfree",
        "documentation": {}
    },
    {
        "label": "get_mem_total",
        "kind": 2,
        "importPath": "modes.memory.memtotal",
        "description": "modes.memory.memtotal",
        "peekOfCode": "def get_mem_total():\n    \"\"\"Get total system memory\"\"\"\n    try:\n        mem = psutil.virtual_memory()\n        return {\n            \"total_bytes\": mem.total,\n            \"total_gb\": round(mem.total / (1024**3), 2)\n        }\n    except Exception as e:\n        return {\"error\": str(e)}",
        "detail": "modes.memory.memtotal",
        "documentation": {}
    },
    {
        "label": "get_mem_usage",
        "kind": 2,
        "importPath": "modes.memory.memusage",
        "description": "modes.memory.memusage",
        "peekOfCode": "def get_mem_usage():\n    \"\"\"Get memory usage percentage\"\"\"\n    try:\n        mem = psutil.virtual_memory()\n        return {\n            \"usage_percent\": mem.percent,\n            \"used_bytes\": mem.used,\n            \"used_gb\": round(mem.used / (1024**3), 2)\n        }\n    except Exception as e:",
        "detail": "modes.memory.memusage",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.ml.aggregator",
        "description": "modes.ml.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for ml monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.ml.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.ml.aggregator",
        "description": "modes.ml.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.ml.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.ml.aggregator",
        "description": "modes.ml.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.ml.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.ml.aggregator",
        "description": "modes.ml.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for ml monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.ml.aggregator",
        "documentation": {}
    },
    {
        "label": "get_anomaly_detection",
        "kind": 2,
        "importPath": "modes.ml.anomaly_detection",
        "description": "modes.ml.anomaly_detection",
        "peekOfCode": "def get_anomaly_detection():\n    \"\"\"Get anomaly detection status and recent anomalies\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load recent anomalies\n        if ANOMALY_LOG.exists():\n            with open(ANOMALY_LOG, 'r') as f:",
        "detail": "modes.ml.anomaly_detection",
        "documentation": {}
    },
    {
        "label": "MODEL_DIR",
        "kind": 5,
        "importPath": "modes.ml.anomaly_detection",
        "description": "modes.ml.anomaly_detection",
        "peekOfCode": "MODEL_DIR = Path(__file__).parent / \"models\"\nDATA_DIR = Path(__file__).parent / \"data\"\nANOMALY_LOG = DATA_DIR / \"anomalies.json\"\ndef get_anomaly_detection():\n    \"\"\"Get anomaly detection status and recent anomalies\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)",
        "detail": "modes.ml.anomaly_detection",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "modes.ml.anomaly_detection",
        "description": "modes.ml.anomaly_detection",
        "peekOfCode": "DATA_DIR = Path(__file__).parent / \"data\"\nANOMALY_LOG = DATA_DIR / \"anomalies.json\"\ndef get_anomaly_detection():\n    \"\"\"Get anomaly detection status and recent anomalies\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load recent anomalies",
        "detail": "modes.ml.anomaly_detection",
        "documentation": {}
    },
    {
        "label": "ANOMALY_LOG",
        "kind": 5,
        "importPath": "modes.ml.anomaly_detection",
        "description": "modes.ml.anomaly_detection",
        "peekOfCode": "ANOMALY_LOG = DATA_DIR / \"anomalies.json\"\ndef get_anomaly_detection():\n    \"\"\"Get anomaly detection status and recent anomalies\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load recent anomalies\n        if ANOMALY_LOG.exists():",
        "detail": "modes.ml.anomaly_detection",
        "documentation": {}
    },
    {
        "label": "get_behavioral_modeling",
        "kind": 2,
        "importPath": "modes.ml.behavioral_modeling",
        "description": "modes.ml.behavioral_modeling",
        "peekOfCode": "def get_behavioral_modeling():\n    \"\"\"Get behavioral modeling status and predictions\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load behavioral model data\n        if BEHAVIOR_LOG.exists():\n            with open(BEHAVIOR_LOG, 'r') as f:",
        "detail": "modes.ml.behavioral_modeling",
        "documentation": {}
    },
    {
        "label": "MODEL_DIR",
        "kind": 5,
        "importPath": "modes.ml.behavioral_modeling",
        "description": "modes.ml.behavioral_modeling",
        "peekOfCode": "MODEL_DIR = Path(__file__).parent / \"models\"\nDATA_DIR = Path(__file__).parent / \"data\"\nBEHAVIOR_LOG = DATA_DIR / \"behavior_models.json\"\ndef get_behavioral_modeling():\n    \"\"\"Get behavioral modeling status and predictions\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)",
        "detail": "modes.ml.behavioral_modeling",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "modes.ml.behavioral_modeling",
        "description": "modes.ml.behavioral_modeling",
        "peekOfCode": "DATA_DIR = Path(__file__).parent / \"data\"\nBEHAVIOR_LOG = DATA_DIR / \"behavior_models.json\"\ndef get_behavioral_modeling():\n    \"\"\"Get behavioral modeling status and predictions\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load behavioral model data",
        "detail": "modes.ml.behavioral_modeling",
        "documentation": {}
    },
    {
        "label": "BEHAVIOR_LOG",
        "kind": 5,
        "importPath": "modes.ml.behavioral_modeling",
        "description": "modes.ml.behavioral_modeling",
        "peekOfCode": "BEHAVIOR_LOG = DATA_DIR / \"behavior_models.json\"\ndef get_behavioral_modeling():\n    \"\"\"Get behavioral modeling status and predictions\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load behavioral model data\n        if BEHAVIOR_LOG.exists():",
        "detail": "modes.ml.behavioral_modeling",
        "documentation": {}
    },
    {
        "label": "get_feature_engineering",
        "kind": 2,
        "importPath": "modes.ml.feature_engineering",
        "description": "modes.ml.feature_engineering",
        "peekOfCode": "def get_feature_engineering():\n    \"\"\"Get feature engineering capabilities and extracted features\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load feature engineering data\n        if FEATURES_LOG.exists():\n            with open(FEATURES_LOG, 'r') as f:\n                features_data = json.load(f)\n        else:",
        "detail": "modes.ml.feature_engineering",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "modes.ml.feature_engineering",
        "description": "modes.ml.feature_engineering",
        "peekOfCode": "DATA_DIR = Path(__file__).parent / \"data\"\nFEATURES_LOG = DATA_DIR / \"feature_engineering.json\"\ndef get_feature_engineering():\n    \"\"\"Get feature engineering capabilities and extracted features\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load feature engineering data\n        if FEATURES_LOG.exists():\n            with open(FEATURES_LOG, 'r') as f:",
        "detail": "modes.ml.feature_engineering",
        "documentation": {}
    },
    {
        "label": "FEATURES_LOG",
        "kind": 5,
        "importPath": "modes.ml.feature_engineering",
        "description": "modes.ml.feature_engineering",
        "peekOfCode": "FEATURES_LOG = DATA_DIR / \"feature_engineering.json\"\ndef get_feature_engineering():\n    \"\"\"Get feature engineering capabilities and extracted features\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load feature engineering data\n        if FEATURES_LOG.exists():\n            with open(FEATURES_LOG, 'r') as f:\n                features_data = json.load(f)",
        "detail": "modes.ml.feature_engineering",
        "documentation": {}
    },
    {
        "label": "get_model_training",
        "kind": 2,
        "importPath": "modes.ml.model_training",
        "description": "modes.ml.model_training",
        "peekOfCode": "def get_model_training():\n    \"\"\"Get model training pipeline status and capabilities\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load training log\n        if TRAINING_LOG.exists():\n            with open(TRAINING_LOG, 'r') as f:",
        "detail": "modes.ml.model_training",
        "documentation": {}
    },
    {
        "label": "MODEL_DIR",
        "kind": 5,
        "importPath": "modes.ml.model_training",
        "description": "modes.ml.model_training",
        "peekOfCode": "MODEL_DIR = Path(__file__).parent / \"models\"\nDATA_DIR = Path(__file__).parent / \"data\"\nTRAINING_LOG = DATA_DIR / \"training_log.json\"\ndef get_model_training():\n    \"\"\"Get model training pipeline status and capabilities\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)",
        "detail": "modes.ml.model_training",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "modes.ml.model_training",
        "description": "modes.ml.model_training",
        "peekOfCode": "DATA_DIR = Path(__file__).parent / \"data\"\nTRAINING_LOG = DATA_DIR / \"training_log.json\"\ndef get_model_training():\n    \"\"\"Get model training pipeline status and capabilities\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load training log",
        "detail": "modes.ml.model_training",
        "documentation": {}
    },
    {
        "label": "TRAINING_LOG",
        "kind": 5,
        "importPath": "modes.ml.model_training",
        "description": "modes.ml.model_training",
        "peekOfCode": "TRAINING_LOG = DATA_DIR / \"training_log.json\"\ndef get_model_training():\n    \"\"\"Get model training pipeline status and capabilities\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load training log\n        if TRAINING_LOG.exists():",
        "detail": "modes.ml.model_training",
        "documentation": {}
    },
    {
        "label": "get_neural_networks",
        "kind": 2,
        "importPath": "modes.ml.neural_networks",
        "description": "modes.ml.neural_networks",
        "peekOfCode": "def get_neural_networks():\n    \"\"\"Get neural network models status and capabilities\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load neural network data\n        if NETWORK_LOG.exists():\n            with open(NETWORK_LOG, 'r') as f:",
        "detail": "modes.ml.neural_networks",
        "documentation": {}
    },
    {
        "label": "MODEL_DIR",
        "kind": 5,
        "importPath": "modes.ml.neural_networks",
        "description": "modes.ml.neural_networks",
        "peekOfCode": "MODEL_DIR = Path(__file__).parent / \"models\"\nDATA_DIR = Path(__file__).parent / \"data\"\nNETWORK_LOG = DATA_DIR / \"neural_networks.json\"\ndef get_neural_networks():\n    \"\"\"Get neural network models status and capabilities\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)",
        "detail": "modes.ml.neural_networks",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "modes.ml.neural_networks",
        "description": "modes.ml.neural_networks",
        "peekOfCode": "DATA_DIR = Path(__file__).parent / \"data\"\nNETWORK_LOG = DATA_DIR / \"neural_networks.json\"\ndef get_neural_networks():\n    \"\"\"Get neural network models status and capabilities\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load neural network data",
        "detail": "modes.ml.neural_networks",
        "documentation": {}
    },
    {
        "label": "NETWORK_LOG",
        "kind": 5,
        "importPath": "modes.ml.neural_networks",
        "description": "modes.ml.neural_networks",
        "peekOfCode": "NETWORK_LOG = DATA_DIR / \"neural_networks.json\"\ndef get_neural_networks():\n    \"\"\"Get neural network models status and capabilities\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load neural network data\n        if NETWORK_LOG.exists():",
        "detail": "modes.ml.neural_networks",
        "documentation": {}
    },
    {
        "label": "get_performance_prediction",
        "kind": 2,
        "importPath": "modes.ml.performance_prediction",
        "description": "modes.ml.performance_prediction",
        "peekOfCode": "def get_performance_prediction():\n    \"\"\"Get performance prediction models and forecasts\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load performance prediction data\n        if PERFORMANCE_LOG.exists():\n            with open(PERFORMANCE_LOG, 'r') as f:",
        "detail": "modes.ml.performance_prediction",
        "documentation": {}
    },
    {
        "label": "MODEL_DIR",
        "kind": 5,
        "importPath": "modes.ml.performance_prediction",
        "description": "modes.ml.performance_prediction",
        "peekOfCode": "MODEL_DIR = Path(__file__).parent / \"models\"\nDATA_DIR = Path(__file__).parent / \"data\"\nPERFORMANCE_LOG = DATA_DIR / \"performance_predictions.json\"\ndef get_performance_prediction():\n    \"\"\"Get performance prediction models and forecasts\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)",
        "detail": "modes.ml.performance_prediction",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "modes.ml.performance_prediction",
        "description": "modes.ml.performance_prediction",
        "peekOfCode": "DATA_DIR = Path(__file__).parent / \"data\"\nPERFORMANCE_LOG = DATA_DIR / \"performance_predictions.json\"\ndef get_performance_prediction():\n    \"\"\"Get performance prediction models and forecasts\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load performance prediction data",
        "detail": "modes.ml.performance_prediction",
        "documentation": {}
    },
    {
        "label": "PERFORMANCE_LOG",
        "kind": 5,
        "importPath": "modes.ml.performance_prediction",
        "description": "modes.ml.performance_prediction",
        "peekOfCode": "PERFORMANCE_LOG = DATA_DIR / \"performance_predictions.json\"\ndef get_performance_prediction():\n    \"\"\"Get performance prediction models and forecasts\"\"\"\n    try:\n        if not MODEL_DIR.exists():\n            MODEL_DIR.mkdir(exist_ok=True)\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Load performance prediction data\n        if PERFORMANCE_LOG.exists():",
        "detail": "modes.ml.performance_prediction",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.network.aggregator",
        "description": "modes.network.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for network monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.network.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.network.aggregator",
        "description": "modes.network.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.network.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.network.aggregator",
        "description": "modes.network.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.network.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.network.aggregator",
        "description": "modes.network.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for network monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.network.aggregator",
        "documentation": {}
    },
    {
        "label": "get_net_latency",
        "kind": 2,
        "importPath": "modes.network.net_latency",
        "description": "modes.network.net_latency",
        "peekOfCode": "def get_net_latency():\n    \"\"\"Get network latency by pinging Google DNS\"\"\"\n    try:\n        target_host = \"8.8.8.8\"\n        # Use appropriate ping command for OS\n        if platform.system().lower() == \"windows\":\n            cmd = [\"ping\", \"-n\", \"4\", target_host]\n        else:\n            cmd = [\"ping\", \"-c\", \"4\", target_host]\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)",
        "detail": "modes.network.net_latency",
        "documentation": {}
    },
    {
        "label": "get_net_speed",
        "kind": 2,
        "importPath": "modes.network.net_speed",
        "description": "modes.network.net_speed",
        "peekOfCode": "def get_net_speed():\n    \"\"\"Get network speed by measuring bytes transferred over 1 second\"\"\"\n    try:\n        # For a more accurate measurement, record the actual time elapsed,\n        # as time.sleep(1) is not guaranteed to be exactly one second.\n        start_time = time.monotonic()\n        # Get initial stats\n        stats1 = psutil.net_io_counters()\n        time.sleep(1)\n        end_time = time.monotonic()",
        "detail": "modes.network.net_speed",
        "documentation": {}
    },
    {
        "label": "get_net_usage",
        "kind": 2,
        "importPath": "modes.network.net_usage",
        "description": "modes.network.net_usage",
        "peekOfCode": "def get_net_usage():\n    \"\"\"Get cumulative network I/O statistics, for all and per-interface.\"\"\"\n    try:\n        # Get total usage for all interfaces\n        total_stats = psutil.net_io_counters(pernic=False)\n        # Get usage per interface\n        per_nic_stats = psutil.net_io_counters(pernic=True)\n        interfaces_data = []\n        for nic_name, stats in per_nic_stats.items():\n            interface_data = _format_stats(stats)",
        "detail": "modes.network.net_usage",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.performance.aggregator",
        "description": "modes.performance.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for performance monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.performance.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.performance.aggregator",
        "description": "modes.performance.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.performance.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.performance.aggregator",
        "description": "modes.performance.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.performance.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.performance.aggregator",
        "description": "modes.performance.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for performance monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.performance.aggregator",
        "documentation": {}
    },
    {
        "label": "get_boot_time",
        "kind": 2,
        "importPath": "modes.performance.boot_time",
        "description": "modes.performance.boot_time",
        "peekOfCode": "def get_boot_time():\n    \"\"\"Get boot time and startup performance metrics\"\"\"\n    try:\n        boot_timestamp = psutil.boot_time()\n        boot_datetime = datetime.fromtimestamp(boot_timestamp)\n        result = {\n            \"boot_timestamp\": boot_timestamp,\n            \"boot_time\": boot_datetime.isoformat(),\n            \"platform\": platform.system()\n        }",
        "detail": "modes.performance.boot_time",
        "documentation": {}
    },
    {
        "label": "get_resource_alerts",
        "kind": 2,
        "importPath": "modes.performance.resource_alerts",
        "description": "modes.performance.resource_alerts",
        "peekOfCode": "def get_resource_alerts():\n    \"\"\"Check for resource usage that exceeds thresholds\"\"\"\n    try:\n        # Load configurable thresholds, with safe defaults\n        config_path = Path(__file__).parent / \"resource_alerts_config.json\"\n        thresholds = {\n            \"cpu\": {\"warning\": 80, \"critical\": 90},\n            \"memory\": {\"warning\": 85, \"critical\": 95},\n            \"disk\": {\"warning\": 90, \"critical\": 95}\n        }",
        "detail": "modes.performance.resource_alerts",
        "documentation": {}
    },
    {
        "label": "get_startup_programs",
        "kind": 2,
        "importPath": "modes.performance.startup_programs",
        "description": "modes.performance.startup_programs",
        "peekOfCode": "def get_startup_programs():\n    \"\"\"Get programs that start with the system\"\"\"\n    try:\n        if platform.system() == \"Windows\":\n            # Get startup programs from registry and startup folder\n            # This script is more comprehensive, fetching the command and checking more locations.\n            ps_script = \"\"\"\n            $startupItems = @()\n            # 1. Registry locations\n            $regLocations = @(",
        "detail": "modes.performance.startup_programs",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.power.aggregator",
        "description": "modes.power.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for power monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.power.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.power.aggregator",
        "description": "modes.power.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.power.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.power.aggregator",
        "description": "modes.power.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.power.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.power.aggregator",
        "description": "modes.power.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for power monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.power.aggregator",
        "documentation": {}
    },
    {
        "label": "get_battery_status",
        "kind": 2,
        "importPath": "modes.power.battery_status",
        "description": "modes.power.battery_status",
        "peekOfCode": "def get_battery_status():\n    \"\"\"Get battery status information\"\"\"\n    try:\n        battery = psutil.sensors_battery()\n        if battery is None:\n            return {\"error\": \"No battery detected (desktop system?)\"}\n        # Determine a clear status string\n        if battery.power_plugged:\n            status = \"Fully Charged\" if battery.percent == 100 else \"Charging\"\n        else:",
        "detail": "modes.power.battery_status",
        "documentation": {}
    },
    {
        "label": "get_energy_usage",
        "kind": 2,
        "importPath": "modes.power.energy_usage",
        "description": "modes.power.energy_usage",
        "peekOfCode": "def get_energy_usage():\n    \"\"\"Estimate energy usage based on system load\"\"\"\n    try:\n        cpu_percent = psutil.cpu_percent(interval=1)\n        memory_percent = psutil.virtual_memory().percent\n        # Rough estimation based on typical desktop power consumption\n        base_power = 50  # Base system power in watts\n        cpu_power = (cpu_percent / 100) * 65  # CPU can use up to 65W\n        memory_power = (memory_percent / 100) * 10  # RAM uses ~10W\n        estimated_watts = base_power + cpu_power + memory_power",
        "detail": "modes.power.energy_usage",
        "documentation": {}
    },
    {
        "label": "get_power_plan",
        "kind": 2,
        "importPath": "modes.power.power_plan",
        "description": "modes.power.power_plan",
        "peekOfCode": "def get_power_plan():\n    \"\"\"Get current power plan\"\"\"\n    try:\n        if platform.system() == \"Windows\":\n            result = subprocess.run(\n                [\"powercfg\", \"/getactivescheme\"],\n                capture_output=True, text=True, timeout=10\n            )\n            if result.returncode == 0:\n                output = result.stdout.strip()",
        "detail": "modes.power.power_plan",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.productivity.aggregator",
        "description": "modes.productivity.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for productivity monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.productivity.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.productivity.aggregator",
        "description": "modes.productivity.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.productivity.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.productivity.aggregator",
        "description": "modes.productivity.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.productivity.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.productivity.aggregator",
        "description": "modes.productivity.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for productivity monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.productivity.aggregator",
        "documentation": {}
    },
    {
        "label": "get_focus_assistant",
        "kind": 2,
        "importPath": "modes.productivity.focus_assistant",
        "description": "modes.productivity.focus_assistant",
        "peekOfCode": "def get_focus_assistant():\n    \"\"\"Get focus assistance status and recommendations\"\"\"\n    try:\n        # Load focus session data\n        if FOCUS_LOG.exists():\n            with open(FOCUS_LOG, 'r') as f:\n                focus_data = json.load(f)\n        else:\n            focus_data = {\"sessions\": [], \"goals\": {}}\n        # Load distraction data",
        "detail": "modes.productivity.focus_assistant",
        "documentation": {}
    },
    {
        "label": "FOCUS_LOG",
        "kind": 5,
        "importPath": "modes.productivity.focus_assistant",
        "description": "modes.productivity.focus_assistant",
        "peekOfCode": "FOCUS_LOG = Path(__file__).parent / \"focus_sessions.json\"\nDISTRACTION_LOG = Path(__file__).parent / \"distractions.json\"\ndef get_focus_assistant():\n    \"\"\"Get focus assistance status and recommendations\"\"\"\n    try:\n        # Load focus session data\n        if FOCUS_LOG.exists():\n            with open(FOCUS_LOG, 'r') as f:\n                focus_data = json.load(f)\n        else:",
        "detail": "modes.productivity.focus_assistant",
        "documentation": {}
    },
    {
        "label": "DISTRACTION_LOG",
        "kind": 5,
        "importPath": "modes.productivity.focus_assistant",
        "description": "modes.productivity.focus_assistant",
        "peekOfCode": "DISTRACTION_LOG = Path(__file__).parent / \"distractions.json\"\ndef get_focus_assistant():\n    \"\"\"Get focus assistance status and recommendations\"\"\"\n    try:\n        # Load focus session data\n        if FOCUS_LOG.exists():\n            with open(FOCUS_LOG, 'r') as f:\n                focus_data = json.load(f)\n        else:\n            focus_data = {\"sessions\": [], \"goals\": {}}",
        "detail": "modes.productivity.focus_assistant",
        "documentation": {}
    },
    {
        "label": "get_time_tracking",
        "kind": 2,
        "importPath": "modes.productivity.time_tracking",
        "description": "modes.productivity.time_tracking",
        "peekOfCode": "def get_time_tracking():\n    \"\"\"Get time tracking data and productivity insights\"\"\"\n    try:\n        # Load time tracking data\n        if TIME_LOG.exists():\n            with open(TIME_LOG, 'r') as f:\n                time_data = json.load(f)\n        else:\n            time_data = {\"sessions\": [], \"daily_stats\": {}}\n        # Load current session",
        "detail": "modes.productivity.time_tracking",
        "documentation": {}
    },
    {
        "label": "TIME_LOG",
        "kind": 5,
        "importPath": "modes.productivity.time_tracking",
        "description": "modes.productivity.time_tracking",
        "peekOfCode": "TIME_LOG = Path(__file__).parent / \"time_tracking.json\"\nSESSION_FILE = Path(__file__).parent / \"current_session.json\"\ndef get_time_tracking():\n    \"\"\"Get time tracking data and productivity insights\"\"\"\n    try:\n        # Load time tracking data\n        if TIME_LOG.exists():\n            with open(TIME_LOG, 'r') as f:\n                time_data = json.load(f)\n        else:",
        "detail": "modes.productivity.time_tracking",
        "documentation": {}
    },
    {
        "label": "SESSION_FILE",
        "kind": 5,
        "importPath": "modes.productivity.time_tracking",
        "description": "modes.productivity.time_tracking",
        "peekOfCode": "SESSION_FILE = Path(__file__).parent / \"current_session.json\"\ndef get_time_tracking():\n    \"\"\"Get time tracking data and productivity insights\"\"\"\n    try:\n        # Load time tracking data\n        if TIME_LOG.exists():\n            with open(TIME_LOG, 'r') as f:\n                time_data = json.load(f)\n        else:\n            time_data = {\"sessions\": [], \"daily_stats\": {}}",
        "detail": "modes.productivity.time_tracking",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.security.aggregator",
        "description": "modes.security.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for security monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.security.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.security.aggregator",
        "description": "modes.security.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.security.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.security.aggregator",
        "description": "modes.security.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.security.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.security.aggregator",
        "description": "modes.security.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for security monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.security.aggregator",
        "documentation": {}
    },
    {
        "label": "get_firewall_status",
        "kind": 2,
        "importPath": "modes.security.firewall_status",
        "description": "modes.security.firewall_status",
        "peekOfCode": "def get_firewall_status():\n    \"\"\"Get firewall status\"\"\"\n    try:\n        if platform.system() == \"Windows\":\n            result = subprocess.run(\n                [\"netsh\", \"advfirewall\", \"show\", \"allprofiles\", \"state\"],\n                capture_output=True, text=True, timeout=10\n            )\n            if result.returncode == 0:\n                output = result.stdout",
        "detail": "modes.security.firewall_status",
        "documentation": {}
    },
    {
        "label": "get_login_attempts",
        "kind": 2,
        "importPath": "modes.security.login_attempts",
        "description": "modes.security.login_attempts",
        "peekOfCode": "def get_login_attempts():\n    \"\"\"Get recent login attempts (basic implementation)\"\"\"\n    try:\n        if platform.system() == \"Windows\":\n            # Check Windows Event Log for logon events\n            result = subprocess.run([\n                \"wevtutil\", \"qe\", \"Security\", \"/q:*[System[EventID=4624]]\", \n                \"/c:10\", \"/rd:true\", \"/f:text\"\n            ], capture_output=True, text=True, timeout=15)\n            if result.returncode == 0:",
        "detail": "modes.security.login_attempts",
        "documentation": {}
    },
    {
        "label": "get_open_ports",
        "kind": 2,
        "importPath": "modes.security.open_ports",
        "description": "modes.security.open_ports",
        "peekOfCode": "def get_open_ports():\n    \"\"\"Get open network ports\"\"\"\n    try:\n        connections = psutil.net_connections()\n        listening_ports = []\n        established_connections = []\n        for conn in connections:\n            if conn.status == 'LISTEN':\n                listening_ports.append({\n                    \"port\": conn.laddr.port,",
        "detail": "modes.security.open_ports",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.service.aggregator",
        "description": "modes.service.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for service monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.service.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.service.aggregator",
        "description": "modes.service.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.service.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.service.aggregator",
        "description": "modes.service.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.service.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.service.aggregator",
        "description": "modes.service.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for service monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.service.aggregator",
        "documentation": {}
    },
    {
        "label": "BackgroundMonitor",
        "kind": 6,
        "importPath": "modes.service.background_monitor",
        "description": "modes.service.background_monitor",
        "peekOfCode": "class BackgroundMonitor:\n    def __init__(self):\n        self.running = False\n        self.thread = None\n        self.data_buffer = []\n        self.last_collection = 0\n    def start_monitoring(self):\n        \"\"\"Start the background monitoring service\"\"\"\n        if not self.running:\n            self.running = True",
        "detail": "modes.service.background_monitor",
        "documentation": {}
    },
    {
        "label": "get_background_monitor",
        "kind": 2,
        "importPath": "modes.service.background_monitor",
        "description": "modes.service.background_monitor",
        "peekOfCode": "def get_background_monitor():\n    \"\"\"Get background monitoring service status\"\"\"\n    try:\n        # Load service configuration\n        if CONFIG_FILE.exists():\n            with open(CONFIG_FILE, 'r') as f:\n                config = json.load(f)\n        else:\n            config = {\n                \"enabled\": False,",
        "detail": "modes.service.background_monitor",
        "documentation": {}
    },
    {
        "label": "start_service",
        "kind": 2,
        "importPath": "modes.service.background_monitor",
        "description": "modes.service.background_monitor",
        "peekOfCode": "def start_service():\n    \"\"\"Start the background monitoring service\"\"\"\n    return _monitor_service.start_monitoring()\ndef stop_service():\n    \"\"\"Stop the background monitoring service\"\"\"\n    return _monitor_service.stop_monitoring()\ndef get_service_status():\n    \"\"\"Get current service status\"\"\"\n    return {\n        \"running\": _monitor_service.running,",
        "detail": "modes.service.background_monitor",
        "documentation": {}
    },
    {
        "label": "stop_service",
        "kind": 2,
        "importPath": "modes.service.background_monitor",
        "description": "modes.service.background_monitor",
        "peekOfCode": "def stop_service():\n    \"\"\"Stop the background monitoring service\"\"\"\n    return _monitor_service.stop_monitoring()\ndef get_service_status():\n    \"\"\"Get current service status\"\"\"\n    return {\n        \"running\": _monitor_service.running,\n        \"data_buffer_size\": len(_monitor_service.data_buffer),\n        \"last_collection\": _monitor_service.last_collection\n    }",
        "detail": "modes.service.background_monitor",
        "documentation": {}
    },
    {
        "label": "get_service_status",
        "kind": 2,
        "importPath": "modes.service.background_monitor",
        "description": "modes.service.background_monitor",
        "peekOfCode": "def get_service_status():\n    \"\"\"Get current service status\"\"\"\n    return {\n        \"running\": _monitor_service.running,\n        \"data_buffer_size\": len(_monitor_service.data_buffer),\n        \"last_collection\": _monitor_service.last_collection\n    }",
        "detail": "modes.service.background_monitor",
        "documentation": {}
    },
    {
        "label": "SERVICE_LOG",
        "kind": 5,
        "importPath": "modes.service.background_monitor",
        "description": "modes.service.background_monitor",
        "peekOfCode": "SERVICE_LOG = Path(__file__).parent / \"service_log.json\"\nCONFIG_FILE = Path(__file__).parent / \"service_config.json\"\nclass BackgroundMonitor:\n    def __init__(self):\n        self.running = False\n        self.thread = None\n        self.data_buffer = []\n        self.last_collection = 0\n    def start_monitoring(self):\n        \"\"\"Start the background monitoring service\"\"\"",
        "detail": "modes.service.background_monitor",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.service.background_monitor",
        "description": "modes.service.background_monitor",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"service_config.json\"\nclass BackgroundMonitor:\n    def __init__(self):\n        self.running = False\n        self.thread = None\n        self.data_buffer = []\n        self.last_collection = 0\n    def start_monitoring(self):\n        \"\"\"Start the background monitoring service\"\"\"\n        if not self.running:",
        "detail": "modes.service.background_monitor",
        "documentation": {}
    },
    {
        "label": "_monitor_service",
        "kind": 5,
        "importPath": "modes.service.background_monitor",
        "description": "modes.service.background_monitor",
        "peekOfCode": "_monitor_service = BackgroundMonitor()\ndef get_background_monitor():\n    \"\"\"Get background monitoring service status\"\"\"\n    try:\n        # Load service configuration\n        if CONFIG_FILE.exists():\n            with open(CONFIG_FILE, 'r') as f:\n                config = json.load(f)\n        else:\n            config = {",
        "detail": "modes.service.background_monitor",
        "documentation": {}
    },
    {
        "label": "ContinuousLearner",
        "kind": 6,
        "importPath": "modes.service.continuous_learning",
        "description": "modes.service.continuous_learning",
        "peekOfCode": "class ContinuousLearner:\n    def __init__(self):\n        self.learning_active = False\n        self.learning_thread = None\n        self.last_model_update = 0\n        self.learning_queue = []\n    def start_learning(self):\n        \"\"\"Start continuous learning process\"\"\"\n        if not self.learning_active:\n            self.learning_active = True",
        "detail": "modes.service.continuous_learning",
        "documentation": {}
    },
    {
        "label": "get_continuous_learning",
        "kind": 2,
        "importPath": "modes.service.continuous_learning",
        "description": "modes.service.continuous_learning",
        "peekOfCode": "def get_continuous_learning():\n    \"\"\"Get continuous learning status and insights\"\"\"\n    try:\n        # Load recent model updates\n        recent_updates = []\n        if MODEL_UPDATES.exists():\n            with open(MODEL_UPDATES, 'r') as f:\n                updates_data = json.load(f)\n                recent_updates = updates_data.get(\"updates\", [])[-5:]  # Last 5 updates\n        # Calculate learning statistics",
        "detail": "modes.service.continuous_learning",
        "documentation": {}
    },
    {
        "label": "start_learning",
        "kind": 2,
        "importPath": "modes.service.continuous_learning",
        "description": "modes.service.continuous_learning",
        "peekOfCode": "def start_learning():\n    \"\"\"Start continuous learning\"\"\"\n    return _continuous_learner.start_learning()\ndef stop_learning():\n    \"\"\"Stop continuous learning\"\"\"\n    return _continuous_learner.stop_learning()\ndef add_learning_task(task):\n    \"\"\"Add a task to the learning queue\"\"\"\n    _continuous_learner.learning_queue.append(task)\ndef get_learning_status():",
        "detail": "modes.service.continuous_learning",
        "documentation": {}
    },
    {
        "label": "stop_learning",
        "kind": 2,
        "importPath": "modes.service.continuous_learning",
        "description": "modes.service.continuous_learning",
        "peekOfCode": "def stop_learning():\n    \"\"\"Stop continuous learning\"\"\"\n    return _continuous_learner.stop_learning()\ndef add_learning_task(task):\n    \"\"\"Add a task to the learning queue\"\"\"\n    _continuous_learner.learning_queue.append(task)\ndef get_learning_status():\n    \"\"\"Get current learning status\"\"\"\n    return {\n        \"active\": _continuous_learner.learning_active,",
        "detail": "modes.service.continuous_learning",
        "documentation": {}
    },
    {
        "label": "add_learning_task",
        "kind": 2,
        "importPath": "modes.service.continuous_learning",
        "description": "modes.service.continuous_learning",
        "peekOfCode": "def add_learning_task(task):\n    \"\"\"Add a task to the learning queue\"\"\"\n    _continuous_learner.learning_queue.append(task)\ndef get_learning_status():\n    \"\"\"Get current learning status\"\"\"\n    return {\n        \"active\": _continuous_learner.learning_active,\n        \"queue_size\": len(_continuous_learner.learning_queue),\n        \"last_update\": _continuous_learner.last_model_update\n    }",
        "detail": "modes.service.continuous_learning",
        "documentation": {}
    },
    {
        "label": "get_learning_status",
        "kind": 2,
        "importPath": "modes.service.continuous_learning",
        "description": "modes.service.continuous_learning",
        "peekOfCode": "def get_learning_status():\n    \"\"\"Get current learning status\"\"\"\n    return {\n        \"active\": _continuous_learner.learning_active,\n        \"queue_size\": len(_continuous_learner.learning_queue),\n        \"last_update\": _continuous_learner.last_model_update\n    }",
        "detail": "modes.service.continuous_learning",
        "documentation": {}
    },
    {
        "label": "LEARNING_LOG",
        "kind": 5,
        "importPath": "modes.service.continuous_learning",
        "description": "modes.service.continuous_learning",
        "peekOfCode": "LEARNING_LOG = Path(__file__).parent / \"learning_log.json\"\nMODEL_UPDATES = Path(__file__).parent / \"model_updates.json\"\nclass ContinuousLearner:\n    def __init__(self):\n        self.learning_active = False\n        self.learning_thread = None\n        self.last_model_update = 0\n        self.learning_queue = []\n    def start_learning(self):\n        \"\"\"Start continuous learning process\"\"\"",
        "detail": "modes.service.continuous_learning",
        "documentation": {}
    },
    {
        "label": "MODEL_UPDATES",
        "kind": 5,
        "importPath": "modes.service.continuous_learning",
        "description": "modes.service.continuous_learning",
        "peekOfCode": "MODEL_UPDATES = Path(__file__).parent / \"model_updates.json\"\nclass ContinuousLearner:\n    def __init__(self):\n        self.learning_active = False\n        self.learning_thread = None\n        self.last_model_update = 0\n        self.learning_queue = []\n    def start_learning(self):\n        \"\"\"Start continuous learning process\"\"\"\n        if not self.learning_active:",
        "detail": "modes.service.continuous_learning",
        "documentation": {}
    },
    {
        "label": "_continuous_learner",
        "kind": 5,
        "importPath": "modes.service.continuous_learning",
        "description": "modes.service.continuous_learning",
        "peekOfCode": "_continuous_learner = ContinuousLearner()\ndef get_continuous_learning():\n    \"\"\"Get continuous learning status and insights\"\"\"\n    try:\n        # Load recent model updates\n        recent_updates = []\n        if MODEL_UPDATES.exists():\n            with open(MODEL_UPDATES, 'r') as f:\n                updates_data = json.load(f)\n                recent_updates = updates_data.get(\"updates\", [])[-5:]  # Last 5 updates",
        "detail": "modes.service.continuous_learning",
        "documentation": {}
    },
    {
        "label": "get_system_service",
        "kind": 2,
        "importPath": "modes.service.system_service",
        "description": "modes.service.system_service",
        "peekOfCode": "def get_system_service():\n    \"\"\"Get system service status and controls\"\"\"\n    try:\n        # Load service configuration\n        if SERVICE_CONFIG.exists():\n            with open(SERVICE_CONFIG, 'r') as f:\n                config = json.load(f)\n        else:\n            config = {\n                \"auto_start\": False,",
        "detail": "modes.service.system_service",
        "documentation": {}
    },
    {
        "label": "start_all_services",
        "kind": 2,
        "importPath": "modes.service.system_service",
        "description": "modes.service.system_service",
        "peekOfCode": "def start_all_services():\n    \"\"\"Start all background services\"\"\"\n    try:\n        from .background_monitor import start_service as start_monitor\n        from .continuous_learning import start_learning\n        monitor_started = start_monitor()\n        learning_started = start_learning()\n        # Update service status\n        status = {\n            \"start_time\": time.time(),",
        "detail": "modes.service.system_service",
        "documentation": {}
    },
    {
        "label": "stop_all_services",
        "kind": 2,
        "importPath": "modes.service.system_service",
        "description": "modes.service.system_service",
        "peekOfCode": "def stop_all_services():\n    \"\"\"Stop all background services\"\"\"\n    try:\n        from .background_monitor import stop_service as stop_monitor\n        from .continuous_learning import stop_learning\n        monitor_stopped = stop_monitor()\n        learning_stopped = stop_learning()\n        return {\n            \"success\": True,\n            \"monitoring\": monitor_stopped,",
        "detail": "modes.service.system_service",
        "documentation": {}
    },
    {
        "label": "install_as_service",
        "kind": 2,
        "importPath": "modes.service.system_service",
        "description": "modes.service.system_service",
        "peekOfCode": "def install_as_service():\n    \"\"\"Install as Windows service (placeholder)\"\"\"\n    return {\n        \"message\": \"Service installation requires administrator privileges\",\n        \"instructions\": [\n            \"1. Run command prompt as administrator\",\n            \"2. Navigate to the system directory\",\n            \"3. Run: python service_installer.py install\",\n            \"4. Start service: net start SystemMonitoringService\"\n        ],",
        "detail": "modes.service.system_service",
        "documentation": {}
    },
    {
        "label": "SERVICE_CONFIG",
        "kind": 5,
        "importPath": "modes.service.system_service",
        "description": "modes.service.system_service",
        "peekOfCode": "SERVICE_CONFIG = Path(__file__).parent / \"system_service_config.json\"\nSERVICE_STATUS = Path(__file__).parent / \"service_status.json\"\ndef get_system_service():\n    \"\"\"Get system service status and controls\"\"\"\n    try:\n        # Load service configuration\n        if SERVICE_CONFIG.exists():\n            with open(SERVICE_CONFIG, 'r') as f:\n                config = json.load(f)\n        else:",
        "detail": "modes.service.system_service",
        "documentation": {}
    },
    {
        "label": "SERVICE_STATUS",
        "kind": 5,
        "importPath": "modes.service.system_service",
        "description": "modes.service.system_service",
        "peekOfCode": "SERVICE_STATUS = Path(__file__).parent / \"service_status.json\"\ndef get_system_service():\n    \"\"\"Get system service status and controls\"\"\"\n    try:\n        # Load service configuration\n        if SERVICE_CONFIG.exists():\n            with open(SERVICE_CONFIG, 'r') as f:\n                config = json.load(f)\n        else:\n            config = {",
        "detail": "modes.service.system_service",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.storage.aggregator",
        "description": "modes.storage.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for storage monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.storage.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.storage.aggregator",
        "description": "modes.storage.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.storage.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.storage.aggregator",
        "description": "modes.storage.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.storage.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.storage.aggregator",
        "description": "modes.storage.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for storage monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.storage.aggregator",
        "documentation": {}
    },
    {
        "label": "get_disk_free",
        "kind": 2,
        "importPath": "modes.storage.disk_free",
        "description": "modes.storage.disk_free",
        "peekOfCode": "def get_disk_free():\n    \"\"\"Get free disk space for all drives\"\"\"\n    try:\n        disks = {}\n        for partition in psutil.disk_partitions():\n            try:\n                usage = psutil.disk_usage(partition.mountpoint)\n                disks[partition.device] = {\n                    \"free_bytes\": usage.free,\n                    \"free_gb\": round(usage.free / (1024**3), 2),",
        "detail": "modes.storage.disk_free",
        "documentation": {}
    },
    {
        "label": "get_disk_io",
        "kind": 2,
        "importPath": "modes.storage.disk_io",
        "description": "modes.storage.disk_io",
        "peekOfCode": "def get_disk_io():\n    \"\"\"Get disk I/O statistics\"\"\"\n    try:\n        io = psutil.disk_io_counters()\n        return {\n            \"read_bytes\": io.read_bytes,\n            \"write_bytes\": io.write_bytes,\n            \"read_count\": io.read_count,\n            \"write_count\": io.write_count,\n            \"read_gb\": round(io.read_bytes / (1024**3), 2),",
        "detail": "modes.storage.disk_io",
        "documentation": {}
    },
    {
        "label": "get_disk_total",
        "kind": 2,
        "importPath": "modes.storage.disk_total",
        "description": "modes.storage.disk_total",
        "peekOfCode": "def get_disk_total():\n    \"\"\"Get total disk space for all drives\"\"\"\n    try:\n        disks = {}\n        for partition in psutil.disk_partitions():\n            try:\n                usage = psutil.disk_usage(partition.mountpoint)\n                disks[partition.device] = {\n                    \"total_bytes\": usage.total,\n                    \"total_gb\": round(usage.total / (1024**3), 2),",
        "detail": "modes.storage.disk_total",
        "documentation": {}
    },
    {
        "label": "get_disk_usage",
        "kind": 2,
        "importPath": "modes.storage.disk_usage",
        "description": "modes.storage.disk_usage",
        "peekOfCode": "def get_disk_usage():\n    \"\"\"Get disk usage percentage for all drives\"\"\"\n    try:\n        disks = {}\n        for partition in psutil.disk_partitions():\n            try:\n                usage = psutil.disk_usage(partition.mountpoint)\n                disks[partition.device] = {\n                    \"used_bytes\": usage.used,\n                    \"used_gb\": round(usage.used / (1024**3), 2),",
        "detail": "modes.storage.disk_usage",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.system.aggregator",
        "description": "modes.system.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for system monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.system.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.system.aggregator",
        "description": "modes.system.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.system.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.system.aggregator",
        "description": "modes.system.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.system.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.system.aggregator",
        "description": "modes.system.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for system monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.system.aggregator",
        "documentation": {}
    },
    {
        "label": "get_os_info",
        "kind": 2,
        "importPath": "modes.system.os_info",
        "description": "modes.system.os_info",
        "peekOfCode": "def get_os_info():\n    \"\"\"Get operating system information\"\"\"\n    try:\n        return {\n            \"system\": platform.system(),\n            \"release\": platform.release(),\n            \"version\": platform.version(),\n            \"machine\": platform.machine(),\n            \"processor\": platform.processor(),\n            \"architecture\": platform.architecture()[0],",
        "detail": "modes.system.os_info",
        "documentation": {}
    },
    {
        "label": "get_processes",
        "kind": 2,
        "importPath": "modes.system.processes",
        "description": "modes.system.processes",
        "peekOfCode": "def get_processes():\n    \"\"\"Get running processes information\"\"\"\n    try:\n        processes = []\n        for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):\n            try:\n                processes.append(proc.info)\n            except (psutil.NoSuchProcess, psutil.AccessDenied):\n                pass\n        # Sort by CPU usage",
        "detail": "modes.system.processes",
        "documentation": {}
    },
    {
        "label": "get_uptime",
        "kind": 2,
        "importPath": "modes.system.uptime",
        "description": "modes.system.uptime",
        "peekOfCode": "def get_uptime():\n    \"\"\"Get system uptime\"\"\"\n    try:\n        boot_time = psutil.boot_time()\n        uptime_seconds = datetime.now().timestamp() - boot_time\n        uptime_delta = timedelta(seconds=uptime_seconds)\n        return {\n            \"boot_time\": datetime.fromtimestamp(boot_time).isoformat(),\n            \"uptime_seconds\": int(uptime_seconds),\n            \"uptime_formatted\": str(uptime_delta).split('.')[0],",
        "detail": "modes.system.uptime",
        "documentation": {}
    },
    {
        "label": "get_user_sessions",
        "kind": 2,
        "importPath": "modes.system.user_sessions",
        "description": "modes.system.user_sessions",
        "peekOfCode": "def get_user_sessions():\n    \"\"\"Get active user sessions\"\"\"\n    try:\n        users = psutil.users()\n        sessions = []\n        for user in users:\n            sessions.append({\n                \"name\": user.name,\n                \"terminal\": user.terminal,\n                \"host\": user.host,",
        "detail": "modes.system.user_sessions",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.system_control.aggregator",
        "description": "modes.system_control.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for system_control monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.system_control.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.system_control.aggregator",
        "description": "modes.system_control.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.system_control.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.system_control.aggregator",
        "description": "modes.system_control.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.system_control.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.system_control.aggregator",
        "description": "modes.system_control.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for system_control monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.system_control.aggregator",
        "documentation": {}
    },
    {
        "label": "get_environment_variable",
        "kind": 2,
        "importPath": "modes.system_control.environment_vars",
        "description": "modes.system_control.environment_vars",
        "peekOfCode": "def get_environment_variable(var_name):\n    \"\"\"Get an environment variable value\"\"\"\n    try:\n        value = os.environ.get(var_name)\n        return {\n            \"success\": True,\n            \"variable_name\": var_name,\n            \"value\": value,\n            \"exists\": value is not None\n        }",
        "detail": "modes.system_control.environment_vars",
        "documentation": {}
    },
    {
        "label": "set_environment_variable",
        "kind": 2,
        "importPath": "modes.system_control.environment_vars",
        "description": "modes.system_control.environment_vars",
        "peekOfCode": "def set_environment_variable(var_name, var_value, user_scope=True, permanent=False):\n    \"\"\"Set an environment variable\"\"\"\n    try:\n        # Set for current session\n        os.environ[var_name] = str(var_value)\n        result = {\n            \"success\": True,\n            \"variable_name\": var_name,\n            \"value\": var_value,\n            \"user_scope\": user_scope,",
        "detail": "modes.system_control.environment_vars",
        "documentation": {}
    },
    {
        "label": "delete_environment_variable",
        "kind": 2,
        "importPath": "modes.system_control.environment_vars",
        "description": "modes.system_control.environment_vars",
        "peekOfCode": "def delete_environment_variable(var_name, permanent=False):\n    \"\"\"Delete an environment variable\"\"\"\n    try:\n        # Remove from current session\n        if var_name in os.environ:\n            del os.environ[var_name]\n            session_deleted = True\n        else:\n            session_deleted = False\n        result = {",
        "detail": "modes.system_control.environment_vars",
        "documentation": {}
    },
    {
        "label": "list_environment_variables",
        "kind": 2,
        "importPath": "modes.system_control.environment_vars",
        "description": "modes.system_control.environment_vars",
        "peekOfCode": "def list_environment_variables(filter_pattern=None):\n    \"\"\"List all environment variables\"\"\"\n    try:\n        variables = {}\n        for key, value in os.environ.items():\n            if filter_pattern is None or filter_pattern.lower() in key.lower():\n                variables[key] = {\n                    \"value\": value,\n                    \"length\": len(value)\n                }",
        "detail": "modes.system_control.environment_vars",
        "documentation": {}
    },
    {
        "label": "get_path_variable",
        "kind": 2,
        "importPath": "modes.system_control.environment_vars",
        "description": "modes.system_control.environment_vars",
        "peekOfCode": "def get_path_variable():\n    \"\"\"Get and parse the PATH environment variable\"\"\"\n    try:\n        path_value = os.environ.get(\"PATH\", \"\")\n        separator = \";\" if platform.system() == \"Windows\" else \":\"\n        path_entries = [p.strip() for p in path_value.split(separator) if p.strip()]\n        # Check which paths exist\n        existing_paths = []\n        missing_paths = []\n        for path in path_entries:",
        "detail": "modes.system_control.environment_vars",
        "documentation": {}
    },
    {
        "label": "get_environment_vars",
        "kind": 2,
        "importPath": "modes.system_control.environment_vars",
        "description": "modes.system_control.environment_vars",
        "peekOfCode": "def get_environment_vars():\n    \"\"\"Get environment variables management capabilities\"\"\"\n    try:\n        return {\n            \"functions\": {\n                \"get_environment_variable\": \"get_environment_variable(var_name)\",\n                \"set_environment_variable\": \"set_environment_variable(var_name, var_value, user_scope=True, permanent=False)\",\n                \"delete_environment_variable\": \"delete_environment_variable(var_name, permanent=False)\",\n                \"list_environment_variables\": \"list_environment_variables(filter_pattern=None)\",\n                \"get_path_variable\": \"get_path_variable()\"",
        "detail": "modes.system_control.environment_vars",
        "documentation": {}
    },
    {
        "label": "start_process",
        "kind": 2,
        "importPath": "modes.system_control.process_control",
        "description": "modes.system_control.process_control",
        "peekOfCode": "def start_process(command, args=None, working_dir=None, detached=False):\n    \"\"\"Start a new process\"\"\"\n    try:\n        if args is None:\n            args = []\n        full_command = [command] + args\n        if detached:\n            # Start detached process\n            if platform.system() == \"Windows\":\n                process = subprocess.Popen(",
        "detail": "modes.system_control.process_control",
        "documentation": {}
    },
    {
        "label": "kill_process",
        "kind": 2,
        "importPath": "modes.system_control.process_control",
        "description": "modes.system_control.process_control",
        "peekOfCode": "def kill_process(pid=None, name=None, force=False):\n    \"\"\"Kill a process by PID or name\"\"\"\n    try:\n        killed_processes = []\n        if pid:\n            # Kill by PID\n            try:\n                proc = psutil.Process(pid)\n                proc_info = {\n                    \"pid\": proc.pid,",
        "detail": "modes.system_control.process_control",
        "documentation": {}
    },
    {
        "label": "get_process_info",
        "kind": 2,
        "importPath": "modes.system_control.process_control",
        "description": "modes.system_control.process_control",
        "peekOfCode": "def get_process_info(pid=None, name=None):\n    \"\"\"Get detailed information about a process\"\"\"\n    try:\n        processes = []\n        if pid:\n            # Get by PID\n            try:\n                proc = psutil.Process(pid)\n                processes.append(_get_detailed_process_info(proc))\n            except psutil.NoSuchProcess:",
        "detail": "modes.system_control.process_control",
        "documentation": {}
    },
    {
        "label": "get_process_control",
        "kind": 2,
        "importPath": "modes.system_control.process_control",
        "description": "modes.system_control.process_control",
        "peekOfCode": "def get_process_control():\n    \"\"\"Get process control capabilities\"\"\"\n    try:\n        return {\n            \"functions\": {\n                \"start_process\": \"start_process(command, args=None, working_dir=None, detached=False)\",\n                \"kill_process\": \"kill_process(pid=None, name=None, force=False)\",\n                \"get_process_info\": \"get_process_info(pid=None, name=None)\"\n            },\n            \"features\": [",
        "detail": "modes.system_control.process_control",
        "documentation": {}
    },
    {
        "label": "get_process_manager",
        "kind": 2,
        "importPath": "modes.system_control.process_manager",
        "description": "modes.system_control.process_manager",
        "peekOfCode": "def get_process_manager():\n    \"\"\"Get detailed process management information\"\"\"\n    try:\n        processes = []\n        total_cpu = 0\n        total_memory = 0\n        for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent', 'status', 'create_time']):\n            try:\n                info = proc.info\n                if info['cpu_percent'] is not None:",
        "detail": "modes.system_control.process_manager",
        "documentation": {}
    },
    {
        "label": "read_registry_key",
        "kind": 2,
        "importPath": "modes.system_control.registry_ops",
        "description": "modes.system_control.registry_ops",
        "peekOfCode": "def read_registry_key(key_path, value_name=None):\n    \"\"\"Read a Windows registry key\"\"\"\n    try:\n        if platform.system() != \"Windows\":\n            return {\"error\": \"Registry operations only available on Windows\"}\n        if value_name:\n            # Read specific value\n            result = subprocess.run(\n                [\"reg\", \"query\", key_path, \"/v\", value_name],\n                capture_output=True, text=True, timeout=10",
        "detail": "modes.system_control.registry_ops",
        "documentation": {}
    },
    {
        "label": "write_registry_key",
        "kind": 2,
        "importPath": "modes.system_control.registry_ops",
        "description": "modes.system_control.registry_ops",
        "peekOfCode": "def write_registry_key(key_path, value_name, value_data, value_type=\"REG_SZ\"):\n    \"\"\"Write to Windows registry\"\"\"\n    try:\n        if platform.system() != \"Windows\":\n            return {\"error\": \"Registry operations only available on Windows\"}\n        result = subprocess.run(\n            [\"reg\", \"add\", key_path, \"/v\", value_name, \"/t\", value_type, \"/d\", str(value_data), \"/f\"],\n            capture_output=True, text=True, timeout=10\n        )\n        success = result.returncode == 0",
        "detail": "modes.system_control.registry_ops",
        "documentation": {}
    },
    {
        "label": "delete_registry_key",
        "kind": 2,
        "importPath": "modes.system_control.registry_ops",
        "description": "modes.system_control.registry_ops",
        "peekOfCode": "def delete_registry_key(key_path, value_name=None):\n    \"\"\"Delete Windows registry key or value\"\"\"\n    try:\n        if platform.system() != \"Windows\":\n            return {\"error\": \"Registry operations only available on Windows\"}\n        if value_name:\n            # Delete specific value\n            result = subprocess.run(\n                [\"reg\", \"delete\", key_path, \"/v\", value_name, \"/f\"],\n                capture_output=True, text=True, timeout=10",
        "detail": "modes.system_control.registry_ops",
        "documentation": {}
    },
    {
        "label": "backup_registry_key",
        "kind": 2,
        "importPath": "modes.system_control.registry_ops",
        "description": "modes.system_control.registry_ops",
        "peekOfCode": "def backup_registry_key(key_path, backup_file):\n    \"\"\"Backup Windows registry key to file\"\"\"\n    try:\n        if platform.system() != \"Windows\":\n            return {\"error\": \"Registry operations only available on Windows\"}\n        result = subprocess.run(\n            [\"reg\", \"export\", key_path, backup_file, \"/y\"],\n            capture_output=True, text=True, timeout=30\n        )\n        success = result.returncode == 0",
        "detail": "modes.system_control.registry_ops",
        "documentation": {}
    },
    {
        "label": "get_registry_ops",
        "kind": 2,
        "importPath": "modes.system_control.registry_ops",
        "description": "modes.system_control.registry_ops",
        "peekOfCode": "def get_registry_ops():\n    \"\"\"Get registry operations capabilities\"\"\"\n    try:\n        return {\n            \"functions\": {\n                \"read_registry_key\": \"read_registry_key(key_path, value_name=None)\",\n                \"write_registry_key\": \"write_registry_key(key_path, value_name, value_data, value_type='REG_SZ')\",\n                \"delete_registry_key\": \"delete_registry_key(key_path, value_name=None)\",\n                \"backup_registry_key\": \"backup_registry_key(key_path, backup_file)\"\n            },",
        "detail": "modes.system_control.registry_ops",
        "documentation": {}
    },
    {
        "label": "create_scheduled_task",
        "kind": 2,
        "importPath": "modes.system_control.scheduled_tasks",
        "description": "modes.system_control.scheduled_tasks",
        "peekOfCode": "def create_scheduled_task(task_name, command, schedule_type=\"daily\", schedule_time=\"09:00\"):\n    \"\"\"Create a scheduled task\"\"\"\n    try:\n        if platform.system() == \"Windows\":\n            # Windows Task Scheduler\n            result = subprocess.run([\n                \"schtasks\", \"/create\",\n                \"/tn\", task_name,\n                \"/tr\", command,\n                \"/sc\", schedule_type,",
        "detail": "modes.system_control.scheduled_tasks",
        "documentation": {}
    },
    {
        "label": "delete_scheduled_task",
        "kind": 2,
        "importPath": "modes.system_control.scheduled_tasks",
        "description": "modes.system_control.scheduled_tasks",
        "peekOfCode": "def delete_scheduled_task(task_name):\n    \"\"\"Delete a scheduled task\"\"\"\n    try:\n        if platform.system() == \"Windows\":\n            result = subprocess.run([\n                \"schtasks\", \"/delete\",\n                \"/tn\", task_name,\n                \"/f\"\n            ], capture_output=True, text=True, timeout=30)\n            success = result.returncode == 0",
        "detail": "modes.system_control.scheduled_tasks",
        "documentation": {}
    },
    {
        "label": "list_scheduled_tasks",
        "kind": 2,
        "importPath": "modes.system_control.scheduled_tasks",
        "description": "modes.system_control.scheduled_tasks",
        "peekOfCode": "def list_scheduled_tasks():\n    \"\"\"List all scheduled tasks\"\"\"\n    try:\n        tasks = []\n        if platform.system() == \"Windows\":\n            result = subprocess.run([\n                \"schtasks\", \"/query\", \"/fo\", \"csv\"\n            ], capture_output=True, text=True, timeout=30)\n            if result.returncode == 0:\n                lines = result.stdout.strip().split('\\n')",
        "detail": "modes.system_control.scheduled_tasks",
        "documentation": {}
    },
    {
        "label": "get_scheduled_tasks",
        "kind": 2,
        "importPath": "modes.system_control.scheduled_tasks",
        "description": "modes.system_control.scheduled_tasks",
        "peekOfCode": "def get_scheduled_tasks():\n    \"\"\"Get scheduled tasks management capabilities\"\"\"\n    try:\n        return {\n            \"functions\": {\n                \"create_scheduled_task\": \"create_scheduled_task(task_name, command, schedule_type='daily', schedule_time='09:00')\",\n                \"delete_scheduled_task\": \"delete_scheduled_task(task_name)\",\n                \"list_scheduled_tasks\": \"list_scheduled_tasks()\"\n            },\n            \"schedule_types\": [\"daily\", \"weekly\", \"monthly\"],",
        "detail": "modes.system_control.scheduled_tasks",
        "documentation": {}
    },
    {
        "label": "get_service_status",
        "kind": 2,
        "importPath": "modes.system_control.service_control",
        "description": "modes.system_control.service_control",
        "peekOfCode": "def get_service_status(service_name):\n    \"\"\"Get status of a system service\"\"\"\n    try:\n        if platform.system() == \"Windows\":\n            result = subprocess.run(\n                [\"sc\", \"query\", service_name],\n                capture_output=True, text=True, timeout=10\n            )\n            if result.returncode == 0:\n                output = result.stdout",
        "detail": "modes.system_control.service_control",
        "documentation": {}
    },
    {
        "label": "start_service",
        "kind": 2,
        "importPath": "modes.system_control.service_control",
        "description": "modes.system_control.service_control",
        "peekOfCode": "def start_service(service_name):\n    \"\"\"Start a system service\"\"\"\n    try:\n        if platform.system() == \"Windows\":\n            result = subprocess.run(\n                [\"sc\", \"start\", service_name],\n                capture_output=True, text=True, timeout=30\n            )\n            success = result.returncode == 0\n            return {",
        "detail": "modes.system_control.service_control",
        "documentation": {}
    },
    {
        "label": "stop_service",
        "kind": 2,
        "importPath": "modes.system_control.service_control",
        "description": "modes.system_control.service_control",
        "peekOfCode": "def stop_service(service_name):\n    \"\"\"Stop a system service\"\"\"\n    try:\n        if platform.system() == \"Windows\":\n            result = subprocess.run(\n                [\"sc\", \"stop\", service_name],\n                capture_output=True, text=True, timeout=30\n            )\n            success = result.returncode == 0\n            return {",
        "detail": "modes.system_control.service_control",
        "documentation": {}
    },
    {
        "label": "list_services",
        "kind": 2,
        "importPath": "modes.system_control.service_control",
        "description": "modes.system_control.service_control",
        "peekOfCode": "def list_services(status_filter=None):\n    \"\"\"List system services\"\"\"\n    try:\n        services = []\n        if platform.system() == \"Windows\":\n            result = subprocess.run(\n                [\"sc\", \"query\"],\n                capture_output=True, text=True, timeout=30\n            )\n            if result.returncode == 0:",
        "detail": "modes.system_control.service_control",
        "documentation": {}
    },
    {
        "label": "get_service_control",
        "kind": 2,
        "importPath": "modes.system_control.service_control",
        "description": "modes.system_control.service_control",
        "peekOfCode": "def get_service_control():\n    \"\"\"Get service control capabilities\"\"\"\n    try:\n        return {\n            \"functions\": {\n                \"get_service_status\": \"get_service_status(service_name)\",\n                \"start_service\": \"start_service(service_name)\",\n                \"stop_service\": \"stop_service(service_name)\",\n                \"list_services\": \"list_services(status_filter=None)\"\n            },",
        "detail": "modes.system_control.service_control",
        "documentation": {}
    },
    {
        "label": "get_service_manager",
        "kind": 2,
        "importPath": "modes.system_control.service_manager",
        "description": "modes.system_control.service_manager",
        "peekOfCode": "def get_service_manager():\n    \"\"\"Get system services status\"\"\"\n    try:\n        if platform.system() == \"Windows\":\n            # Get Windows services\n            result = subprocess.run([\n                \"sc\", \"query\", \"state=\", \"all\"\n            ], capture_output=True, text=True, timeout=15)\n            if result.returncode == 0:\n                services = []",
        "detail": "modes.system_control.service_manager",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "modes.visual.aggregator",
        "description": "modes.visual.aggregator",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for visual monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{module_name}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "modes.visual.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "modes.visual.aggregator",
        "description": "modes.visual.aggregator",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "modes.visual.aggregator",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "modes.visual.aggregator",
        "description": "modes.visual.aggregator",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "modes.visual.aggregator",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "modes.visual.aggregator",
        "description": "modes.visual.aggregator",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for visual monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {mode_name}. Available: {list(MODES.keys())}\")\n    results = {}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "modes.visual.aggregator",
        "documentation": {}
    },
    {
        "label": "get_ocr_analysis",
        "kind": 2,
        "importPath": "modes.visual.ocr_analysis",
        "description": "modes.visual.ocr_analysis",
        "peekOfCode": "def get_ocr_analysis():\n    \"\"\"Get OCR analysis capabilities and recent text extractions\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Check for recent OCR results\n        ocr_files = list(DATA_DIR.glob(\"*.json\"))\n        recent_ocr = []\n        for file in ocr_files[-5:]:  # Last 5 OCR results\n            try:",
        "detail": "modes.visual.ocr_analysis",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "modes.visual.ocr_analysis",
        "description": "modes.visual.ocr_analysis",
        "peekOfCode": "DATA_DIR = Path(__file__).parent / \"ocr_data\"\ndef get_ocr_analysis():\n    \"\"\"Get OCR analysis capabilities and recent text extractions\"\"\"\n    try:\n        if not DATA_DIR.exists():\n            DATA_DIR.mkdir(exist_ok=True)\n        # Check for recent OCR results\n        ocr_files = list(DATA_DIR.glob(\"*.json\"))\n        recent_ocr = []\n        for file in ocr_files[-5:]:  # Last 5 OCR results",
        "detail": "modes.visual.ocr_analysis",
        "documentation": {}
    },
    {
        "label": "get_screen_capture",
        "kind": 2,
        "importPath": "modes.visual.screen_capture",
        "description": "modes.visual.screen_capture",
        "peekOfCode": "def get_screen_capture():\n    \"\"\"Get screen capture capabilities and recent captures\"\"\"\n    try:\n        if not CAPTURE_DIR.exists():\n            CAPTURE_DIR.mkdir(exist_ok=True)\n        # Get recent captures\n        captures = []\n        for file in CAPTURE_DIR.glob(\"*.png\"):\n            captures.append({\n                \"filename\": file.name,",
        "detail": "modes.visual.screen_capture",
        "documentation": {}
    },
    {
        "label": "CAPTURE_DIR",
        "kind": 5,
        "importPath": "modes.visual.screen_capture",
        "description": "modes.visual.screen_capture",
        "peekOfCode": "CAPTURE_DIR = Path(__file__).parent / \"captures\"\nCAPTURE_LOG = Path(__file__).parent / \"capture_log.json\"\ndef get_screen_capture():\n    \"\"\"Get screen capture capabilities and recent captures\"\"\"\n    try:\n        if not CAPTURE_DIR.exists():\n            CAPTURE_DIR.mkdir(exist_ok=True)\n        # Get recent captures\n        captures = []\n        for file in CAPTURE_DIR.glob(\"*.png\"):",
        "detail": "modes.visual.screen_capture",
        "documentation": {}
    },
    {
        "label": "CAPTURE_LOG",
        "kind": 5,
        "importPath": "modes.visual.screen_capture",
        "description": "modes.visual.screen_capture",
        "peekOfCode": "CAPTURE_LOG = Path(__file__).parent / \"capture_log.json\"\ndef get_screen_capture():\n    \"\"\"Get screen capture capabilities and recent captures\"\"\"\n    try:\n        if not CAPTURE_DIR.exists():\n            CAPTURE_DIR.mkdir(exist_ok=True)\n        # Get recent captures\n        captures = []\n        for file in CAPTURE_DIR.glob(\"*.png\"):\n            captures.append({",
        "detail": "modes.visual.screen_capture",
        "documentation": {}
    },
    {
        "label": "get_ui_detection",
        "kind": 2,
        "importPath": "modes.visual.ui_detection",
        "description": "modes.visual.ui_detection",
        "peekOfCode": "def get_ui_detection():\n    \"\"\"Get UI detection capabilities and recent detections\"\"\"\n    try:\n        # Load recent detections\n        if DETECTION_LOG.exists():\n            with open(DETECTION_LOG, 'r') as f:\n                detections = json.load(f)\n        else:\n            detections = {\"detections\": []}\n        # Simulate some UI detection data",
        "detail": "modes.visual.ui_detection",
        "documentation": {}
    },
    {
        "label": "DETECTION_LOG",
        "kind": 5,
        "importPath": "modes.visual.ui_detection",
        "description": "modes.visual.ui_detection",
        "peekOfCode": "DETECTION_LOG = Path(__file__).parent / \"ui_detections.json\"\ndef get_ui_detection():\n    \"\"\"Get UI detection capabilities and recent detections\"\"\"\n    try:\n        # Load recent detections\n        if DETECTION_LOG.exists():\n            with open(DETECTION_LOG, 'r') as f:\n                detections = json.load(f)\n        else:\n            detections = {\"detections\": []}",
        "detail": "modes.visual.ui_detection",
        "documentation": {}
    },
    {
        "label": "build_aggregator",
        "kind": 2,
        "importPath": "scripts.build_aggregators",
        "description": "scripts.build_aggregators",
        "peekOfCode": "def build_aggregator(category):\n    category_path = BASE_DIR / category\n    if not category_path.exists():\n        print(f\"Skipping {category} - no folder found.\")\n        return\n    modules = [\n        f.stem for f in category_path.glob(\"*.py\")\n        if f.name not in (\"__init__.py\", \"aggregator.py\")\n    ]\n    if not modules:",
        "detail": "scripts.build_aggregators",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "scripts.build_aggregators",
        "description": "scripts.build_aggregators",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for {category} monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {{mode_name}}. Available: {{list(MODES.keys())}}\")\n    results = {{}}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{{module_name}}\", __package__)\n            # Find the main function (look for get_* functions first, then others)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]",
        "detail": "scripts.build_aggregators",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "scripts.build_aggregators",
        "description": "scripts.build_aggregators",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "scripts.build_aggregators",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "scripts.build_aggregators",
        "description": "scripts.build_aggregators",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "scripts.build_aggregators",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.build_aggregators",
        "description": "scripts.build_aggregators",
        "peekOfCode": "def main():\n    \"\"\"Build aggregators for all category folders\"\"\"\n    if not BASE_DIR.exists():\n        BASE_DIR.mkdir(parents=True)\n        print(f\"Created {BASE_DIR}\")\n    categories = [d.name for d in BASE_DIR.iterdir() if d.is_dir()]\n    if not categories:\n        print(\"No category folders found. Creating example structure...\")\n        return\n    for cat in categories:",
        "detail": "scripts.build_aggregators",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "scripts.build_aggregators",
        "description": "scripts.build_aggregators",
        "peekOfCode": "BASE_DIR = Path(__file__).parent / \"modes\"\ndef build_aggregator(category):\n    category_path = BASE_DIR / category\n    if not category_path.exists():\n        print(f\"Skipping {category} - no folder found.\")\n        return\n    modules = [\n        f.stem for f in category_path.glob(\"*.py\")\n        if f.name not in (\"__init__.py\", \"aggregator.py\")\n    ]",
        "detail": "scripts.build_aggregators",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "scripts.build_aggregators",
        "description": "scripts.build_aggregators",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for {category} monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {{mode_name}}. Available: {{list(MODES.keys())}}\")\n    results = {{}}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "scripts.build_aggregators",
        "documentation": {}
    },
    {
        "label": "create_directory_structure",
        "kind": 2,
        "importPath": "scripts.cleanup_project",
        "description": "scripts.cleanup_project",
        "peekOfCode": "def create_directory_structure():\n    \"\"\"Create organized directory structure\"\"\"\n    directories = [\n        \"docs\",\n        \"scripts\", \n        \"config\",\n        \"logs\",\n        \"backups\",\n        \"tests\"\n    ]",
        "detail": "scripts.cleanup_project",
        "documentation": {}
    },
    {
        "label": "organize_documentation",
        "kind": 2,
        "importPath": "scripts.cleanup_project",
        "description": "scripts.cleanup_project",
        "peekOfCode": "def organize_documentation():\n    \"\"\"Move documentation files to docs directory\"\"\"\n    doc_files = [\n        \"README.md\",\n        \"Current_Structure.txt\", \n        \"FINAL_SYSTEM_OVERVIEW.md\",\n        \"AI_SYSTEM_SUMMARY.md\",\n        \"AUDIO_SYSTEM_SUMMARY.md\",\n        \"AUTO_UPDATE_SYSTEM.md\",\n        \"EXPANSION_SUMMARY.md\",",
        "detail": "scripts.cleanup_project",
        "documentation": {}
    },
    {
        "label": "organize_scripts",
        "kind": 2,
        "importPath": "scripts.cleanup_project",
        "description": "scripts.cleanup_project",
        "peekOfCode": "def organize_scripts():\n    \"\"\"Move utility scripts to scripts directory\"\"\"\n    script_files = [\n        \"build_aggregators.py\",\n        \"update_structure.py\", \n        \"watch_structure.py\",\n        \"setup_auto_update.py\",\n        \"cleanup_project.py\",\n        \"install_service.py\",\n        \"start_service.py\"",
        "detail": "scripts.cleanup_project",
        "documentation": {}
    },
    {
        "label": "organize_config",
        "kind": 2,
        "importPath": "scripts.cleanup_project",
        "description": "scripts.cleanup_project",
        "peekOfCode": "def organize_config():\n    \"\"\"Move configuration files to config directory\"\"\"\n    config_files = [\n        \"global_config.json\"\n    ]\n    config_dir = Path(\"config\")\n    moved_files = []\n    for config_file in config_files:\n        if Path(config_file).exists():\n            shutil.move(config_file, config_dir / config_file)",
        "detail": "scripts.cleanup_project",
        "documentation": {}
    },
    {
        "label": "organize_batch_files",
        "kind": 2,
        "importPath": "scripts.cleanup_project",
        "description": "scripts.cleanup_project",
        "peekOfCode": "def organize_batch_files():\n    \"\"\"Move batch files to scripts directory\"\"\"\n    batch_files = [\n        \"update_structure.bat\",\n        \"watch_structure.bat\", \n        \"build_and_update.bat\"\n    ]\n    scripts_dir = Path(\"scripts\")\n    moved_files = []\n    for batch_file in batch_files:",
        "detail": "scripts.cleanup_project",
        "documentation": {}
    },
    {
        "label": "create_requirements_file",
        "kind": 2,
        "importPath": "scripts.cleanup_project",
        "description": "scripts.cleanup_project",
        "peekOfCode": "def create_requirements_file():\n    \"\"\"Create requirements.txt file\"\"\"\n    requirements = \"\"\"# System Monitoring Framework Requirements\n# Core dependencies (required for basic functionality)\npsutil>=5.9.0\n# Audio processing (for audio modules)\n# pyaudio>=0.2.11\n# sounddevice>=0.4.6\n# pycaw>=20230407\n# Machine learning (for ML modules)  ",
        "detail": "scripts.cleanup_project",
        "documentation": {}
    },
    {
        "label": "create_project_info",
        "kind": 2,
        "importPath": "scripts.cleanup_project",
        "description": "scripts.cleanup_project",
        "peekOfCode": "def create_project_info():\n    \"\"\"Create project information files\"\"\"\n    # Create VERSION file\n    with open(\"VERSION\", \"w\") as f:\n        f.write(\"0.1.0-beta\\n\")\n    print(\" Created VERSION file\")\n    # Create CHANGELOG.md\n    changelog = \"\"\"# Changelog\n## [0.1.0-beta] - 2024-01-15\n### Added",
        "detail": "scripts.cleanup_project",
        "documentation": {}
    },
    {
        "label": "create_final_backup",
        "kind": 2,
        "importPath": "scripts.cleanup_project",
        "description": "scripts.cleanup_project",
        "peekOfCode": "def create_final_backup():\n    \"\"\"Create final organized backup\"\"\"\n    import datetime\n    timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    backup_name = f\"SystemMonitoringFramework_ORGANIZED_{timestamp}.zip\"\n    try:\n        import zipfile\n        with zipfile.ZipFile(backup_name, 'w', zipfile.ZIP_DEFLATED) as zipf:\n            # Add all files and directories\n            for root, dirs, files in os.walk(\".\"):",
        "detail": "scripts.cleanup_project",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.cleanup_project",
        "description": "scripts.cleanup_project",
        "peekOfCode": "def main():\n    \"\"\"Main cleanup function\"\"\"\n    print(\" Project Cleanup & Organization\")\n    print(\"=\" * 40)\n    # Create directory structure\n    print(\"\\n Creating directory structure...\")\n    create_directory_structure()\n    # Organize files\n    print(\"\\n Organizing documentation...\")\n    organize_documentation()",
        "detail": "scripts.cleanup_project",
        "documentation": {}
    },
    {
        "label": "install_startup_script",
        "kind": 2,
        "importPath": "scripts.install_service",
        "description": "scripts.install_service",
        "peekOfCode": "def install_startup_script():\n    \"\"\"Install service to Windows startup folder\"\"\"\n    try:\n        # Get Windows startup folder\n        startup_folder = Path(os.path.expandvars(r'%APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup'))\n        if not startup_folder.exists():\n            print(\" Windows startup folder not found\")\n            return False\n        # Create startup script\n        current_dir = Path(__file__).parent.parent.absolute()",
        "detail": "scripts.install_service",
        "documentation": {}
    },
    {
        "label": "create_desktop_shortcut",
        "kind": 2,
        "importPath": "scripts.install_service",
        "description": "scripts.install_service",
        "peekOfCode": "def create_desktop_shortcut():\n    \"\"\"Create desktop shortcut for manual service control\"\"\"\n    try:\n        desktop = Path(os.path.expandvars(r'%USERPROFILE%\\Desktop'))\n        current_dir = Path(__file__).parent.parent.absolute()\n        # Create start service shortcut\n        start_shortcut_content = f'''@echo off\ntitle System Monitoring Service\ncd /d \"{current_dir}\"\npython start_service.py",
        "detail": "scripts.install_service",
        "documentation": {}
    },
    {
        "label": "install_task_scheduler",
        "kind": 2,
        "importPath": "scripts.install_service",
        "description": "scripts.install_service",
        "peekOfCode": "def install_task_scheduler():\n    \"\"\"Create Windows Task Scheduler entry\"\"\"\n    try:\n        current_dir = Path(__file__).parent.parent.absolute()\n        python_exe = sys.executable\n        # Create XML for task scheduler\n        task_xml = f'''<?xml version=\"1.0\" encoding=\"UTF-16\"?>\n<Task version=\"1.2\" xmlns=\"http://schemas.microsoft.com/windows/2004/02/mit/task\">\n  <RegistrationInfo>\n    <Date>2024-01-01T00:00:00</Date>",
        "detail": "scripts.install_service",
        "documentation": {}
    },
    {
        "label": "check_dependencies",
        "kind": 2,
        "importPath": "scripts.install_service",
        "description": "scripts.install_service",
        "peekOfCode": "def check_dependencies():\n    \"\"\"Check if required dependencies are installed\"\"\"\n    try:\n        import psutil\n        print(\" psutil is installed\")\n    except ImportError:\n        print(\" psutil is not installed\")\n        print(\" Install with: pip install psutil\")\n        return False\n    # Check if service modules exist",
        "detail": "scripts.install_service",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.install_service",
        "description": "scripts.install_service",
        "peekOfCode": "def main():\n    \"\"\"Main installation function\"\"\"\n    print(\" System Monitoring Service Installer\")\n    print(\"=\" * 50)\n    if not check_dependencies():\n        print(\"\\n Installation cannot proceed due to missing dependencies\")\n        return 1\n    print(\"\\n Installation Options:\")\n    print(\"1. Startup Folder (Recommended)\")\n    print(\"2. Task Scheduler (Advanced)\")",
        "detail": "scripts.install_service",
        "documentation": {}
    },
    {
        "label": "setup_git_hooks",
        "kind": 2,
        "importPath": "scripts.setup_auto_update",
        "description": "scripts.setup_auto_update",
        "peekOfCode": "def setup_git_hooks():\n    \"\"\"Setup git hooks to auto-update structure on commits\"\"\"\n    try:\n        git_dir = Path(\".git\")\n        if not git_dir.exists():\n            print(\"  No git repository found - skipping git hooks\")\n            return False\n        hooks_dir = git_dir / \"hooks\"\n        hooks_dir.mkdir(exist_ok=True)\n        # Create pre-commit hook",
        "detail": "scripts.setup_auto_update",
        "documentation": {}
    },
    {
        "label": "setup_vscode_tasks",
        "kind": 2,
        "importPath": "scripts.setup_auto_update",
        "description": "scripts.setup_auto_update",
        "peekOfCode": "def setup_vscode_tasks():\n    \"\"\"Setup VS Code tasks for easy structure updates\"\"\"\n    try:\n        vscode_dir = Path(\".vscode\")\n        vscode_dir.mkdir(exist_ok=True)\n        tasks_file = vscode_dir / \"tasks.json\"\n        tasks_config = {\n            \"version\": \"2.0.0\",\n            \"tasks\": [\n                {",
        "detail": "scripts.setup_auto_update",
        "documentation": {}
    },
    {
        "label": "create_batch_scripts",
        "kind": 2,
        "importPath": "scripts.setup_auto_update",
        "description": "scripts.setup_auto_update",
        "peekOfCode": "def create_batch_scripts():\n    \"\"\"Create convenient batch scripts for Windows\"\"\"\n    try:\n        # Update structure script\n        update_bat = Path(\"update_structure.bat\")\n        with open(update_bat, \"w\", encoding=\"utf-8\") as f:\n            f.write(\"\"\"@echo off\ntitle Update Structure File\necho Updating Current_Structure.txt...\npython update_structure.py",
        "detail": "scripts.setup_auto_update",
        "documentation": {}
    },
    {
        "label": "test_auto_update",
        "kind": 2,
        "importPath": "scripts.setup_auto_update",
        "description": "scripts.setup_auto_update",
        "peekOfCode": "def test_auto_update():\n    \"\"\"Test the auto-update system\"\"\"\n    try:\n        print(\" Testing auto-update system...\")\n        sys.path.append(str(Path(__file__).parent))\n        from update_structure import update_structure_file\n        success = update_structure_file()\n        if success:\n            print(\" Auto-update system working correctly\")\n            return True",
        "detail": "scripts.setup_auto_update",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.setup_auto_update",
        "description": "scripts.setup_auto_update",
        "peekOfCode": "def main():\n    \"\"\"Main setup function\"\"\"\n    print(\" Auto-Update System Setup\")\n    print(\"=\" * 40)\n    success_count = 0\n    total_tasks = 4\n    # Test the system first\n    if test_auto_update():\n        success_count += 1\n        print()",
        "detail": "scripts.setup_auto_update",
        "documentation": {}
    },
    {
        "label": "signal_handler",
        "kind": 2,
        "importPath": "scripts.start_service",
        "description": "scripts.start_service",
        "peekOfCode": "def signal_handler(sig, frame):\n    \"\"\"Handle Ctrl+C gracefully\"\"\"\n    print(\"\\n Stopping System Monitoring Service...\")\n    try:\n        from modes.service.system_service import stop_all_services\n        result = stop_all_services()\n        if result[\"success\"]:\n            print(\" Services stopped successfully\")\n        else:\n            print(f\" Error stopping services: {result.get('error', 'Unknown error')}\")",
        "detail": "scripts.start_service",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.start_service",
        "description": "scripts.start_service",
        "peekOfCode": "def main():\n    \"\"\"Main service startup function\"\"\"\n    print(\" Starting System Monitoring & Learning Service...\")\n    print(\"=\" * 60)\n    try:\n        # Import service modules\n        from modes.service.system_service import start_all_services, get_system_service\n        # Get service info\n        service_info = get_system_service()\n        print(f\" Service Status: {service_info.get('status', 'Unknown')}\")",
        "detail": "scripts.start_service",
        "documentation": {}
    },
    {
        "label": "scan_modes_directory",
        "kind": 2,
        "importPath": "scripts.update_structure",
        "description": "scripts.update_structure",
        "peekOfCode": "def scan_modes_directory():\n    \"\"\"Scan the modes directory and build structure data\"\"\"\n    modes_dir = Path(__file__).parent.parent / \"modes\"\n    if not modes_dir.exists():\n        return {}\n    structure = {}\n    total_modules = 0\n    for category_dir in sorted(modes_dir.iterdir()):\n        if not category_dir.is_dir() or category_dir.name.startswith('.') or category_dir.name == '__pycache__':\n            continue",
        "detail": "scripts.update_structure",
        "documentation": {}
    },
    {
        "label": "generate_structure_content",
        "kind": 2,
        "importPath": "scripts.update_structure",
        "description": "scripts.update_structure",
        "peekOfCode": "def generate_structure_content(structure, total_modules):\n    \"\"\"Generate the content for Current_Structure.txt\"\"\"\n    category_count = len(structure)\n    content = f\"\"\"# System Monitoring & Automation Framework - Current Structure\n## Overview\nA comprehensive modular system with {category_count} categories and {total_modules}+ individual modules for monitoring hardware, system performance, user activity, and automating tasks. Each module performs a single function with auto-generated aggregators.\n## Key Features\n- **Modular Design**: Each .py file does exactly one thing\n- **Auto-Aggregation**: Drop files in folders, run build script, everything's wired\n- **Mode System**: basic/detailed/all modes per category  ",
        "detail": "scripts.update_structure",
        "documentation": {}
    },
    {
        "label": "update_structure_file",
        "kind": 2,
        "importPath": "scripts.update_structure",
        "description": "scripts.update_structure",
        "peekOfCode": "def update_structure_file():\n    \"\"\"Update the Current_Structure.txt file\"\"\"\n    try:\n        print(\" Scanning modes directory...\")\n        structure, total_modules = scan_modes_directory()\n        if not structure:\n            print(\" No modules found in modes directory\")\n            return False\n        print(f\" Found {len(structure)} categories with {total_modules} total modules\")\n        # Generate new content",
        "detail": "scripts.update_structure",
        "documentation": {}
    },
    {
        "label": "watch_for_changes",
        "kind": 2,
        "importPath": "scripts.update_structure",
        "description": "scripts.update_structure",
        "peekOfCode": "def watch_for_changes():\n    \"\"\"Watch for changes in the modes directory (basic implementation)\"\"\"\n    print(\"  Watching modes directory for changes...\")\n    print(\" Run this script manually after adding modules, or integrate with file watcher\")\n    print(\" To auto-update: python update_structure.py\")\ndef main():\n    \"\"\"Main function\"\"\"\n    print(\" System Structure Auto-Updater\")\n    print(\"=\" * 40)\n    success = update_structure_file()",
        "detail": "scripts.update_structure",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.update_structure",
        "description": "scripts.update_structure",
        "peekOfCode": "def main():\n    \"\"\"Main function\"\"\"\n    print(\" System Structure Auto-Updater\")\n    print(\"=\" * 40)\n    success = update_structure_file()\n    if success:\n        print(\"\\n Structure file updated successfully!\")\n        print(\"\\n Integration options:\")\n        print(\"    Run manually: python update_structure.py\")\n        print(\"    Add to build_aggregators.py for automatic updates\")",
        "detail": "scripts.update_structure",
        "documentation": {}
    },
    {
        "label": "SimpleFileWatcher",
        "kind": 6,
        "importPath": "scripts.watch_structure",
        "description": "scripts.watch_structure",
        "peekOfCode": "class SimpleFileWatcher:\n    def __init__(self, watch_dir):\n        self.watch_dir = Path(__file__).parent.parent / watch_dir\n        self.last_scan = {}\n        self.scan_directory()\n    def scan_directory(self):\n        \"\"\"Scan directory and record file modification times\"\"\"\n        current_scan = {}\n        if not self.watch_dir.exists():\n            return current_scan",
        "detail": "scripts.watch_structure",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.watch_structure",
        "description": "scripts.watch_structure",
        "peekOfCode": "def main():\n    \"\"\"Main file watcher function\"\"\"\n    print(\"  Structure File Watcher\")\n    print(\"=\" * 40)\n    print(\" Watching modes/ directory for changes...\")\n    print(\" Will auto-update Current_Structure.txt when modules are added/changed\")\n    print(\" Press Ctrl+C to stop\")\n    print()\n    watcher = SimpleFileWatcher(\"modes\")\n    try:",
        "detail": "scripts.watch_structure",
        "documentation": {}
    },
    {
        "label": "TestCpuAggregator",
        "kind": 6,
        "importPath": "tests.modes.cpu.test_aggregator",
        "description": "tests.modes.cpu.test_aggregator",
        "peekOfCode": "class TestCpuAggregator(unittest.TestCase):\n    def test_list_modes(self):\n        \"\"\"Test that list_modes returns the correct list of modes.\"\"\"\n        modes = aggregator.list_modes()\n        self.assertEqual(sorted(modes), sorted(['all', 'basic', 'detailed']))\n    def test_list_modules(self):\n        \"\"\"Test that list_modules returns the correct list of modules.\"\"\"\n        modules = aggregator.list_modules()\n        self.assertEqual(sorted(modules), sorted(['cpu_usage', 'cpuspeed', 'cputemp']))\n    def test_run_mode_all(self):",
        "detail": "tests.modes.cpu.test_aggregator",
        "documentation": {}
    },
    {
        "label": "TestCpuSpeed",
        "kind": 6,
        "importPath": "tests.modes.cpu.test_cpuspeed",
        "description": "tests.modes.cpu.test_cpuspeed",
        "peekOfCode": "class TestCpuSpeed(unittest.TestCase):\n    def test_get_cpu_speed_structure_and_values(self):\n        \"\"\"\n        Test the structure and values of the dictionary returned by get_cpu_speed.\n        \"\"\"\n        speed_data = get_cpu_speed()\n        if \"error\" in speed_data:\n            self.assertIsInstance(speed_data[\"error\"], str)\n        else:\n            self.assertIn(\"current_mhz\", speed_data)",
        "detail": "tests.modes.cpu.test_cpuspeed",
        "documentation": {}
    },
    {
        "label": "TestCpuTemp",
        "kind": 6,
        "importPath": "tests.modes.cpu.test_cputemp",
        "description": "tests.modes.cpu.test_cputemp",
        "peekOfCode": "class TestCpuTemp(unittest.TestCase):\n    def test_get_cpu_temp_structure(self):\n        \"\"\"\n        Test the structure of the dictionary returned by get_cpu_temp, including fallback to py_cpuinfo.\n        \"\"\"\n        temp_data = get_cpu_temp()\n        if \"error\" in temp_data:\n            self.assertIsInstance(temp_data[\"error\"], str)\n        else:\n            self.assertIn(\"temp_celsius\", temp_data)",
        "detail": "tests.modes.cpu.test_cputemp",
        "documentation": {}
    },
    {
        "label": "TestCpuUsage",
        "kind": 6,
        "importPath": "tests.modes.cpu.test_cpu_usage",
        "description": "tests.modes.cpu.test_cpu_usage",
        "peekOfCode": "class TestCpuUsage(unittest.TestCase):\n    def test_get_cpu_usage_structure_and_values(self):\n        \"\"\"\n        Test the structure and values of the dictionary returned by get_cpu_usage.\n        Handles None and error cases for Pylance compatibility.\n        \"\"\"\n        usage_data = get_cpu_usage()\n        self.assertIsInstance(usage_data, dict)\n        if usage_data is None:\n            self.fail(\"get_cpu_usage() returned None\")",
        "detail": "tests.modes.cpu.test_cpu_usage",
        "documentation": {}
    },
    {
        "label": "build_aggregator",
        "kind": 2,
        "importPath": "build_aggregators",
        "description": "build_aggregators",
        "peekOfCode": "def build_aggregator(category):\n    category_path = BASE_DIR / category\n    if not category_path.exists():\n        print(f\"Skipping {category} - no folder found.\")\n        return\n    modules = [\n        f.stem for f in category_path.glob(\"*.py\")\n        if f.name not in (\"__init__.py\", \"aggregator.py\")\n    ]\n    if not modules:",
        "detail": "build_aggregators",
        "documentation": {}
    },
    {
        "label": "run_mode",
        "kind": 2,
        "importPath": "build_aggregators",
        "description": "build_aggregators",
        "peekOfCode": "def run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for {category} monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {{mode_name}}. Available: {{list(MODES.keys())}}\")\n    results = {{}}\n    for module_name in MODES[mode_name]:\n        try:\n            mod = importlib.import_module(f\".{{module_name}}\", __package__)\n            all_funcs = [f for f in dir(mod) if not f.startswith(\"_\") and callable(getattr(mod, f))]\n            excluded = {{'Path', 'datetime', 'os', 'sys', 'json', 'time', 'subprocess', 'platform', 'shutil'}}",
        "detail": "build_aggregators",
        "documentation": {}
    },
    {
        "label": "list_modes",
        "kind": 2,
        "importPath": "build_aggregators",
        "description": "build_aggregators",
        "peekOfCode": "def list_modes():\n    \"\"\"List available modes\"\"\"\n    return list(MODES.keys())\ndef list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":",
        "detail": "build_aggregators",
        "documentation": {}
    },
    {
        "label": "list_modules",
        "kind": 2,
        "importPath": "build_aggregators",
        "description": "build_aggregators",
        "peekOfCode": "def list_modules():\n    \"\"\"List available modules\"\"\"\n    all_modules = set()\n    for modules in MODES.values():\n        all_modules.update(modules)\n    return sorted(all_modules)\nif __name__ == \"__main__\":\n    import sys\n    mode = sys.argv[1] if len(sys.argv) > 1 else \"all\"\n    print(json.dumps(run_mode(mode), indent=2))",
        "detail": "build_aggregators",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "build_aggregators",
        "description": "build_aggregators",
        "peekOfCode": "def main():\n    \"\"\"Build aggregators for all category folders\"\"\"\n    if not BASE_DIR.exists():\n        BASE_DIR.mkdir(parents=True)\n        print(f\"Created {BASE_DIR}\")\n    categories = [d.name for d in BASE_DIR.iterdir() if d.is_dir()]\n    if not categories:\n        print(\"No category folders found. Creating example structure...\")\n        return\n    for cat in categories:",
        "detail": "build_aggregators",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "build_aggregators",
        "description": "build_aggregators",
        "peekOfCode": "BASE_DIR = Path(__file__).parent / \"modes\"\ndef build_aggregator(category):\n    category_path = BASE_DIR / category\n    if not category_path.exists():\n        print(f\"Skipping {category} - no folder found.\")\n        return\n    modules = [\n        f.stem for f in category_path.glob(\"*.py\")\n        if f.name not in (\"__init__.py\", \"aggregator.py\")\n    ]",
        "detail": "build_aggregators",
        "documentation": {}
    },
    {
        "label": "CONFIG_FILE",
        "kind": 5,
        "importPath": "build_aggregators",
        "description": "build_aggregators",
        "peekOfCode": "CONFIG_FILE = Path(__file__).parent / \"config.json\"\nwith open(CONFIG_FILE) as f:\n    MODES = json.load(f)\ndef run_mode(mode_name=\"all\"):\n    \"\"\"Run specified mode for {category} monitoring\"\"\"\n    if mode_name not in MODES:\n        raise ValueError(f\"Unknown mode: {{mode_name}}. Available: {{list(MODES.keys())}}\")\n    results = {{}}\n    for module_name in MODES[mode_name]:\n        try:",
        "detail": "build_aggregators",
        "documentation": {}
    },
    {
        "label": "run_system_mode",
        "kind": 2,
        "importPath": "main_aggregator",
        "description": "main_aggregator",
        "peekOfCode": "def run_system_mode(mode=\"basic\", categories=None):\n    \"\"\"\n    Run monitoring across specified categories\n    Args:\n        mode: Mode to run (basic, detailed, all)\n        categories: List of categories to monitor (default: all available)\n    \"\"\"\n    if categories is None:\n        categories = [d.name for d in MODES_DIR.iterdir() \n                     if d.is_dir() and (d / \"aggregator.py\").exists()]",
        "detail": "main_aggregator",
        "documentation": {}
    },
    {
        "label": "list_categories",
        "kind": 2,
        "importPath": "main_aggregator",
        "description": "main_aggregator",
        "peekOfCode": "def list_categories():\n    \"\"\"List all available monitoring categories\"\"\"\n    return [d.name for d in MODES_DIR.iterdir() \n            if d.is_dir() and (d / \"aggregator.py\").exists()]\ndef get_category_modes(category):\n    \"\"\"Get available modes for a specific category\"\"\"\n    try:\n        mod = importlib.import_module(f\"modes.{category}.aggregator\")\n        return mod.list_modes()\n    except Exception as e:",
        "detail": "main_aggregator",
        "documentation": {}
    },
    {
        "label": "get_category_modes",
        "kind": 2,
        "importPath": "main_aggregator",
        "description": "main_aggregator",
        "peekOfCode": "def get_category_modes(category):\n    \"\"\"Get available modes for a specific category\"\"\"\n    try:\n        mod = importlib.import_module(f\"modes.{category}.aggregator\")\n        return mod.list_modes()\n    except Exception as e:\n        return {\"error\": str(e)}\nif __name__ == \"__main__\":\n    import sys\n    if len(sys.argv) > 1:",
        "detail": "main_aggregator",
        "documentation": {}
    },
    {
        "label": "MODES_DIR",
        "kind": 5,
        "importPath": "main_aggregator",
        "description": "main_aggregator",
        "peekOfCode": "MODES_DIR = Path(__file__).parent / \"modes\"\ndef run_system_mode(mode=\"basic\", categories=None):\n    \"\"\"\n    Run monitoring across specified categories\n    Args:\n        mode: Mode to run (basic, detailed, all)\n        categories: List of categories to monitor (default: all available)\n    \"\"\"\n    if categories is None:\n        categories = [d.name for d in MODES_DIR.iterdir() ",
        "detail": "main_aggregator",
        "documentation": {}
    },
    {
        "label": "signal_handler",
        "kind": 2,
        "importPath": "start_service",
        "description": "start_service",
        "peekOfCode": "def signal_handler(sig, frame):\n    \"\"\"Handle Ctrl+C gracefully\"\"\"\n    print(\"\\n Stopping System Monitoring Service...\")\n    try:\n        from modes.service.system_service import stop_all_services\n        result = stop_all_services()\n        if result[\"success\"]:\n            print(\" Services stopped successfully\")\n        else:\n            print(f\" Error stopping services: {result.get('error', 'Unknown error')}\")",
        "detail": "start_service",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "start_service",
        "description": "start_service",
        "peekOfCode": "def main():\n    \"\"\"Main service startup function\"\"\"\n    print(\" Starting System Monitoring & Learning Service...\")\n    print(\"=\" * 60)\n    try:\n        # Import service modules\n        from modes.service.system_service import start_all_services, get_system_service\n        # Get service info\n        service_info = get_system_service()\n        print(f\" Service Status: {service_info.get('status', 'Unknown')}\")",
        "detail": "start_service",
        "documentation": {}
    }
]